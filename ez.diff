Index: src/sound.cpp
===================================================================
--- src/sound.cpp	(revision 12652)
+++ src/sound.cpp	(working copy)
@@ -166,7 +166,7 @@
 }
 
 
-static const byte _vol_factor_by_zoom[] = {255, 190, 134, 87};
+static const byte _vol_factor_by_zoom[] = {255, 255, 255, 190, 134, 87};
 assert_compile(lengthof(_vol_factor_by_zoom) == ZOOM_LVL_END - ZOOM_LVL_BEGIN);
 
 static const byte _sound_base_vol[] = {
Index: src/rail_cmd.cpp
===================================================================
--- src/rail_cmd.cpp	(revision 12652)
+++ src/rail_cmd.cpp	(working copy)
@@ -2231,12 +2231,15 @@
 }
 
 static const byte _fractcoords_behind[4] = { 0x8F, 0x8, 0x80, 0xF8 };
-static const byte _fractcoords_enter[4] = { 0x8A, 0x48, 0x84, 0xA8 };
+static const byte _fractcoords_enter[4] = { 0x88, 0x88, 0x88, 0x88 };
 static const signed char _deltacoord_leaveoffset[8] = {
-	-1,  0,  1,  0, /* x */
-	 0,  1,  0, -1  /* y */
+	 1,  0, -1,  0, /* x */
+	 0, -1,  0,  1  /* y */
 };
+// static const byte _fractcoords_leave[4] = { 0x80, 0xF8, 0x8F, 0x08 };
 
+//static const byte _vehicle_initial_x_fract[4] = { 15, 8, 0, 8};
+//static const byte _vehicle_initial_y_fract[4] = { 8, 0, 8, 15};
 
 /** Compute number of ticks when next wagon will leave a depot.
  * Negative means next wagon should have left depot n ticks before.
@@ -2263,9 +2266,10 @@
 static VehicleEnterTileStatus VehicleEnter_Track(Vehicle *v, TileIndex tile, int x, int y)
 {
 	byte fract_coord;
-	byte fract_coord_leave;
+//	byte fract_coord_leave;
 	DiagDirection dir;
 	int length;
+	Vehicle *p;
 
 	/* this routine applies only to trains in depot tiles */
 	if (v->type != VEH_TRAIN || !IsTileDepotType(tile, TRANSPORT_RAIL)) return VETSB_CONTINUE;
@@ -2277,19 +2281,21 @@
 	/* this depends on the length of the current vehicle */
 	length = v->u.rail.cached_veh_length;
 
-	fract_coord_leave =
-		((_fractcoords_enter[dir] & 0x0F) + // x
-			(length + 1) * _deltacoord_leaveoffset[dir]) +
-		(((_fractcoords_enter[dir] >> 4) +  // y
-			((length + 1) * _deltacoord_leaveoffset[dir+4])) << 4);
 
+//	fract_coord_leave =
+//		((_fractcoords_leave[dir] & 0x0F) + // x
+//			(0xF-length) * _deltacoord_leaveoffset[dir])  +
+//		(((_fractcoords_leave[dir] >> 4) +  // y
+//			((0xF-length ) * _deltacoord_leaveoffset[dir+4])) << 4);
+			
 	fract_coord = (x & 0xF) + ((y & 0xF) << 4);
 
 	if (_fractcoords_behind[dir] == fract_coord) {
 		/* make sure a train is not entering the tile from behind */
 		return VETSB_CANNOT_ENTER;
-	} else if (_fractcoords_enter[dir] == fract_coord) {
-		if (DiagDirToDir(ReverseDiagDir(dir)) == v->direction) {
+	} else
+	if (DiagDirToDir(ReverseDiagDir(dir)) == v->direction) { 
+		if (_fractcoords_enter[dir] == fract_coord) {
 			/* enter the depot */
 			v->u.rail.track = TRACK_BIT_DEPOT,
 			v->vehstatus |= VS_HIDDEN; /* hide it */
@@ -2300,16 +2306,43 @@
 			InvalidateWindowData(WC_VEHICLE_DEPOT, v->tile);
 			return VETSB_ENTERED_WORMHOLE;
 		}
-	} else if (fract_coord_leave == fract_coord) {
-		if (DiagDirToDir(dir) == v->direction) {
-			/* leave the depot? */
-			if ((v = v->Next()) != NULL) {
-				v->vehstatus &= ~VS_HIDDEN;
-				v->u.rail.track = (DiagDirToAxis(dir) == AXIS_X ? TRACK_BIT_X : TRACK_BIT_Y);
+	} else {
+		bool leave = false;
+		if ( (p = v->Previous()) != NULL){   // carriages 		
+			if (!(p->vehstatus & VS_HIDDEN)) { // prev carriage or engine already outside.
+				switch (dir) {
+					case DIAGDIR_NE: leave = (v->x_pos - p->x_pos >= 0xE);
+						break;
+					case DIAGDIR_SE: leave = (p->y_pos - v->y_pos >= 0xE);
+						break;
+					case DIAGDIR_SW: leave = (p->x_pos - v->x_pos >= 0xE);
+						break;
+					case DIAGDIR_NW: leave = (v->y_pos - p->y_pos >= 0xE);
+						break;
+					default: leave = false;
+						break;
+				}
+				if (leave){
+					v->vehstatus &= ~VS_HIDDEN;
+					v->u.rail.track = (DiagDirToAxis(dir) == AXIS_X ? TRACK_BIT_X : TRACK_BIT_Y);					
+				}
 			}
 		}
+//		else if (fract_coord_leave == fract_coord) {
+//			if (DiagDirToDir(dir) == v->direction) {
+			/* leave the depot? */
+//				if ((v = v->Next()) != NULL) {
+//					v->vehstatus &= ~VS_HIDDEN;
+//					v->u.rail.track = (DiagDirToAxis(dir) == AXIS_X ? TRACK_BIT_X : TRACK_BIT_Y);
+//				v->x_pos = (v->x_pos & ~0x0F) | _vehicle_initial_x_fract[dir];
+//				v->y_pos = (v->y_pos & ~0x0F) | _vehicle_initial_y_fract[dir];
+//			   }
+//		   }
+//	   }
 	}
+	
 
+
 	return VETSB_CONTINUE;
 }
 
Index: src/station_cmd.cpp
===================================================================
--- src/station_cmd.cpp	(revision 12652)
+++ src/station_cmd.cpp	(working copy)
@@ -2199,7 +2199,8 @@
 		}
 
 		SpriteID pal;
-		if (!(!HasBit(image, SPRITE_MODIFIER_OPAQUE) && IsTransparencySet(TO_BUILDINGS)) && HasBit(image, PALETTE_MODIFIER_COLOR)) {
+		if (/*(HasBit(image, SPRITE_MODIFIER_OPAQUE) ||!IsTransparencySet(TO_BUILDINGS) )
+		  &&*/ HasBit(image, PALETTE_MODIFIER_COLOR)) {
 			pal = palette;
 		} else {
 			pal = dtss->image.pal;
@@ -2418,7 +2419,6 @@
 				if (x == 12) return VETSB_ENTERED_STATION | (VehicleEnterTileStatus)(station_id << VETS_STATION_ID_OFFSET); /* enter station */
 				if (x < 12) {
 					uint16 spd;
-
 					v->vehstatus |= VS_TRAIN_SLOWING;
 					spd = _enter_station_speedtable[x];
 					if (spd < v->cur_speed) v->cur_speed = spd;
Index: src/table/sprites.h
===================================================================
--- src/table/sprites.h	(revision 12652)
+++ src/table/sprites.h	(working copy)
@@ -1427,7 +1427,7 @@
 	RECOLOR_BIT = 30,           ///< toggles recoloring in the sprite
 	OFFSET_BIT = 29,
 	OPAQUE_BIT = 28,
-
+	SHADOW_BIT = 27,
 	PALETTE_WIDTH = 24,         ///< number of bits of the sprite containing the recolor palette
 	SPRITE_WIDTH = 24,          ///< number of bits for the sprite number
 };
@@ -1454,6 +1454,7 @@
 	PALETTE_MODIFIER_GREYOUT        = TRANSPARENT_BIT,
 	///Set when a colortable mode is used. @see GfxFillRect
 	USE_COLORTABLE                  = RECOLOR_BIT,
+  	PALETTE_MODIFIER_SHADOW        = SHADOW_BIT,
 };
 
 /** Masks needed for sprite operations.
Index: src/spriteloader/grf.cpp
===================================================================
--- src/spriteloader/grf.cpp	(revision 12652)
+++ src/spriteloader/grf.cpp	(working copy)
@@ -9,7 +9,7 @@
 #include "../core/alloc_func.hpp"
 #include "grf.hpp"
 
-bool SpriteLoaderGrf::LoadSprite(SpriteLoader::Sprite *sprite, uint8 file_slot, uint32 file_pos)
+bool SpriteLoaderGrf::LoadSprite(SpriteLoader::Sprite *sprite, uint8 file_slot, uint32 file_pos, ZoomLevel zoom)
 {
 	/* Open the right file and go to the correct position */
 	FioSeekToFile(file_slot, file_pos);
Index: src/spriteloader/spriteloader.hpp
===================================================================
--- src/spriteloader/spriteloader.hpp	(revision 12652)
+++ src/spriteloader/spriteloader.hpp	(working copy)
@@ -26,8 +26,7 @@
 	/**
 	 * Load a sprite from the disk and return a sprite struct which is the same for all loaders.
 	 */
-	virtual bool LoadSprite(SpriteLoader::Sprite *sprite, uint8 file_slot, uint32 file_pos) = 0;
-
+	virtual bool LoadSprite(SpriteLoader::Sprite *sprite, uint8 file_slot, uint32 file_pos, ZoomLevel zoom) = 0;
 	virtual ~SpriteLoader() { }
 };
 
Index: src/spriteloader/grf.hpp
===================================================================
--- src/spriteloader/grf.hpp	(revision 12652)
+++ src/spriteloader/grf.hpp	(working copy)
@@ -12,7 +12,7 @@
 	/**
 	 * Load a sprite from the disk and return a sprite struct which is the same for all loaders.
 	 */
-	bool LoadSprite(SpriteLoader::Sprite *sprite, uint8 file_slot, uint32 file_pos);
+	bool LoadSprite(SpriteLoader::Sprite *sprite, uint8 file_slot, uint32 file_pos, ZoomLevel zoom);
 };
 
 #endif /* SPRITELOADER_GRF_HPP */
Index: src/spriteloader/png.cpp
===================================================================
--- src/spriteloader/png.cpp	(revision 12652)
+++ src/spriteloader/png.cpp	(working copy)
@@ -30,21 +30,28 @@
 	DEBUG(sprite, 0, "WARNING (libpng): %s - %s", message, (char *)png_get_error_ptr(png_ptr));
 }
 
-static bool OpenPNGFile(const char *filename, uint32 id, bool mask)
+static bool OpenPNGFile(const char *filename, uint32 id, bool mask, ZoomLevel zoom)
 {
 	char png_file[MAX_PATH];
 
-	snprintf(png_file, sizeof(png_file), "sprites" PATHSEP "%s" PATHSEP "%d%s.png", filename, id, mask ? "m" : "");
+	snprintf(png_file, sizeof(png_file), "sprites" PATHSEP "%s" PATHSEP "%d_%s%d%s.png", filename, id, "z",zoom,mask ? "m" : "");
 	if (FioCheckFileExists(png_file)) {
 		FioOpenFile(PNG_SLOT, png_file);
 		return true;
 	}
-
+	/* if failed, try to find it in the trunk tars, only for default zoom */
+	if ( zoom == ZOOM_LVL_NORMAL) {
+		snprintf(png_file, sizeof(png_file), "sprites" PATHSEP "%s" PATHSEP "%d%s.png", filename, id, mask ? "m" : "");
+		if (FioCheckFileExists(png_file)) {
+			FioOpenFile(PNG_SLOT, png_file);
+			return true;
+		}
+	}
 	/* TODO -- Add TAR support */
 	return false;
 }
 
-static bool LoadPNG(SpriteLoader::Sprite *sprite, const char *filename, uint32 id, bool mask)
+static bool LoadPNG(SpriteLoader::Sprite *sprite, const char *filename, uint32 id, bool mask, ZoomLevel zoom)
 {
 	png_byte header[8];
 	png_structp png_ptr;
@@ -54,7 +61,7 @@
 	png_bytep row_pointer;
 	SpriteLoader::CommonPixel *dst;
 
-	if (!OpenPNGFile(filename, id, mask)) return mask; // If mask is true, and file not found, continue true anyway, as it isn't a show-stopper
+	if (!OpenPNGFile(filename, id, mask, zoom)) return mask; // If mask is true, and file not found, continue true anyway, as it isn't a show-stopper
 
 	/* Check the header */
 	FioReadBlock(header, 8);
@@ -148,9 +155,7 @@
 		for (uint x = 0; x < info_ptr->width; x++) {
 			if (mask) {
 				if (row_pointer[x * sizeof(uint8)] != 0) {
-					dst[x].r = 0;
-					dst[x].g = 0;
-					dst[x].b = 0;
+					/* GeekToo: dont overwrite sprite rgb data if mask is present */
 					/* Alpha channel is used from the original image (to allow transparency in remap colors) */
 					dst[x].m = row_pointer[x * sizeof(uint8)];
 				}
@@ -170,11 +175,11 @@
 	return true;
 }
 
-bool SpriteLoaderPNG::LoadSprite(SpriteLoader::Sprite *sprite, uint8 file_slot, uint32 file_pos)
+bool SpriteLoaderPNG::LoadSprite(SpriteLoader::Sprite *sprite, uint8 file_slot, uint32 file_pos, ZoomLevel zoom)
 {
 	const char *filename = FioGetFilename(file_slot);
-	if (!LoadPNG(sprite, filename, file_pos, false)) return false;
-	if (!LoadPNG(sprite, filename, file_pos, true)) return false;
+	if (!LoadPNG(sprite, filename, file_pos, false, zoom)) return false;
+	if (!LoadPNG(sprite, filename, file_pos, true, zoom)) return false;
 	return true;
 }
 
Index: src/spriteloader/png.hpp
===================================================================
--- src/spriteloader/png.hpp	(revision 12652)
+++ src/spriteloader/png.hpp	(working copy)
@@ -12,7 +12,7 @@
 	/**
 	 * Load a sprite from the disk and return a sprite struct which is the same for all loaders.
 	 */
-	bool LoadSprite(SpriteLoader::Sprite *sprite, uint8 file_slot, uint32 file_pos);
+	bool LoadSprite(SpriteLoader::Sprite *sprite, uint8 file_slot, uint32 file_pos, ZoomLevel zoom);
 };
 
 #endif /* SPRITELOADER_PNG_HPP */
Index: src/train_cmd.cpp
===================================================================
--- src/train_cmd.cpp	(revision 12652)
+++ src/train_cmd.cpp	(working copy)
@@ -55,10 +55,11 @@
 static void TrainController(Vehicle *v, Vehicle *nomove, bool update_image);
 static TileIndex TrainApproachingCrossingTile(const Vehicle *v);
 
-static const byte _vehicle_initial_x_fract[4] = {10, 8, 4,  8};
-static const byte _vehicle_initial_y_fract[4] = { 8, 4, 8, 10};
 
+static const byte _vehicle_initial_x_fract[4] = { 8, 8, 8, 8};
+static const byte _vehicle_initial_y_fract[4] = { 8, 8, 8, 8};
 
+
 /**
  * Determine the side in which the train will leave the tile
  *
@@ -280,7 +281,7 @@
 		}
 		if (veh_len == CALLBACK_FAILED) veh_len = rvi_u->shorten_factor;
 		veh_len = Clamp(veh_len, 0, u->Next() == NULL ? 7 : 5); // the clamp on vehicles not the last in chain is stricter, as too short wagons can break the 'follow next vehicle' code
-		u->u.rail.cached_veh_length = 8 - veh_len;
+		u->u.rail.cached_veh_length = 0xF- veh_len;
 		v->u.rail.cached_total_length += u->u.rail.cached_veh_length;
 	}
 
@@ -1493,16 +1494,17 @@
 void Train::UpdateDeltaXY(Direction direction)
 {
 #define MKIT(a, b, c, d) ((a & 0xFF) << 24) | ((b & 0xFF) << 16) | ((c & 0xFF) << 8) | ((d & 0xFF) << 0)
+
 	static const uint32 _delta_xy_table[8] = {
-		MKIT(3, 3, -1, -1),
-		MKIT(3, 7, -1, -3),
-		MKIT(3, 3, -1, -1),
-		MKIT(7, 3, -3, -1),
-		MKIT(3, 3, -1, -1),
-		MKIT(3, 7, -1, -3),
-		MKIT(3, 3, -1, -1),
-		MKIT(7, 3, -3, -1),
-	};
+		MKIT(3, 3, -1,  -1),   // N
+		MKIT(3, 15, 0,  -8),   // NE
+		MKIT(3, 3, -1,  -1),    // E
+		MKIT(15, 3, -8, -0),  // SE
+		MKIT(7, 7, -1,  -1),   // S
+		MKIT(3, 15, 0,  -8),   // SW
+		MKIT(7, 7, -1,  -1),   // W
+		MKIT(15, 3, -8,  0),   // NW
+	}; 
 #undef MKIT
 
 	uint32 x = _delta_xy_table[direction];
@@ -2352,12 +2354,12 @@
 }
 
 static const byte _initial_tile_subcoord[6][4][3] = {
-{{ 15, 8, 1 }, { 0, 0, 0 }, { 0, 8, 5 }, { 0,  0, 0 }},
-{{  0, 0, 0 }, { 8, 0, 3 }, { 0, 0, 0 }, { 8, 15, 7 }},
-{{  0, 0, 0 }, { 7, 0, 2 }, { 0, 7, 6 }, { 0,  0, 0 }},
-{{ 15, 8, 2 }, { 0, 0, 0 }, { 0, 0, 0 }, { 8, 15, 6 }},
-{{ 15, 7, 0 }, { 8, 0, 4 }, { 0, 0, 0 }, { 0,  0, 0 }},
-{{  0, 0, 0 }, { 0, 0, 0 }, { 0, 8, 4 }, { 7, 15, 0 }},
+{{ 15, 8, 1 }, { 0, 0, 0 }, { 0, 8, 5 }, { 0,  0, 0 }},  // x
+{{  0, 0, 0 }, { 8, 0, 3 }, { 0, 0, 0 }, { 8, 15, 7 }},  // y
+{{  0, 0, 0 }, { 7, 0, 2 }, { 0, 7, 6 }, { 0,  0, 0 }},  // up
+{{ 15, 8, 2 }, { 0, 0, 0 }, { 0, 0, 0 }, { 8, 15, 6 }},  // low
+{{ 15, 7, 0 }, { 8, 0, 4 }, { 0, 0, 0 }, { 0,  0, 0 }},  // left
+{{  0, 0, 0 }, { 0, 0, 0 }, { 0, 8, 4 }, { 7, 15, 0 }},  // right
 };
 
 static const byte _search_directions[6][4] = {
@@ -2942,6 +2944,7 @@
 					/* Inside depot */
 					gp.x = v->x_pos;
 					gp.y = v->y_pos;
+					VehicleEnterTile(v, gp.new_tile, gp.x, gp.y);
 				} else {
 					/* Not inside depot */
 
@@ -3023,10 +3026,18 @@
 					}
 				} else {
 					static const TrackBits _matching_tracks[8] = {
-							TRACK_BIT_LEFT  | TRACK_BIT_RIGHT, TRACK_BIT_X,
-							TRACK_BIT_UPPER | TRACK_BIT_LOWER, TRACK_BIT_Y,
-							TRACK_BIT_LEFT  | TRACK_BIT_RIGHT, TRACK_BIT_X,
-							TRACK_BIT_UPPER | TRACK_BIT_LOWER, TRACK_BIT_Y
+							TRACK_BIT_LEFT  | TRACK_BIT_RIGHT,     //N
+							TRACK_BIT_X | TRACK_BIT_LEFT | TRACK_BIT_RIGHT |
+											TRACK_BIT_LOWER | TRACK_BIT_UPPER,  //NE
+							TRACK_BIT_UPPER | TRACK_BIT_LOWER,     //E
+							TRACK_BIT_Y | TRACK_BIT_LEFT | TRACK_BIT_RIGHT |
+											TRACK_BIT_LOWER | TRACK_BIT_UPPER, //SE  
+							TRACK_BIT_LEFT  | TRACK_BIT_RIGHT,     //S 
+							TRACK_BIT_X | TRACK_BIT_LEFT | TRACK_BIT_RIGHT |
+											TRACK_BIT_LOWER | TRACK_BIT_UPPER,  //SW
+							TRACK_BIT_UPPER | TRACK_BIT_LOWER,     //W         
+							TRACK_BIT_Y | TRACK_BIT_LEFT | TRACK_BIT_RIGHT |
+											  TRACK_BIT_LOWER | TRACK_BIT_UPPER,  //NW
 					};
 
 					/* The wagon is active, simply follow the prev vehicle. */
@@ -3034,11 +3045,12 @@
 				}
 
 				/* Make sure chosen track is a valid track */
-				assert(
-						chosen_track == TRACK_BIT_X     || chosen_track == TRACK_BIT_Y ||
-						chosen_track == TRACK_BIT_UPPER || chosen_track == TRACK_BIT_LOWER ||
-						chosen_track == TRACK_BIT_LEFT  || chosen_track == TRACK_BIT_RIGHT);
+//				assert(
+//						chosen_track == TRACK_BIT_X     || chosen_track == TRACK_BIT_Y ||
+//						chosen_track == TRACK_BIT_UPPER || chosen_track == TRACK_BIT_LOWER ||
+//						chosen_track == TRACK_BIT_LEFT  || chosen_track == TRACK_BIT_RIGHT);
 
+				assert(chosen_track);
 				/* Update XY to reflect the entrance to the new tile, and select the direction to use */
 				const byte *b = _initial_tile_subcoord[FIND_FIRST_BIT(chosen_track)][enterdir];
 				gp.x = (gp.x & ~0xF) | b[0];
Index: src/spritecache.cpp
===================================================================
--- src/spritecache.cpp	(revision 12652)
+++ src/spritecache.cpp	(working copy)
@@ -7,6 +7,8 @@
 #include "variables.h"
 #include "debug.h"
 #include "spritecache.h"
+#include "gfx_func.h"
+#include "table/sprites.h"
 #include "fileio.h"
 #include "spriteloader/grf.hpp"
 #include "core/alloc_func.hpp"
@@ -15,7 +17,7 @@
 #include "spriteloader/png.hpp"
 #endif /* WITH_PNG */
 #include "blitter/factory.hpp"
-
+#include "blitter/32bpp_optimized.hpp"
 #include "table/sprites.h"
 
 /* Default of 4MB spritecache */
@@ -23,7 +25,7 @@
 
 
 struct SpriteCache {
-	void *ptr;
+	void *ptr[ZOOM_LVL_END];
 	uint32 id;
 	uint32 file_pos;
 	uint16 file_slot;
@@ -51,6 +53,10 @@
 
 		_spritecache = ReallocT(_spritecache, items);
 
+		if (_spritecache == NULL) {
+			error("Unable to allocate sprite cache of %d items (%d bytes)", items, items * sizeof(*_spritecache));
+		}
+
 		/* Reset the new items and update the count */
 		memset(_spritecache + _spritecache_items, 0, (items - _spritecache_items) * sizeof(*_spritecache));
 		_spritecache_items = items;
@@ -124,8 +130,11 @@
 {
 	uint8 file_slot = sc->file_slot;
 	uint32 file_pos = sc->file_pos;
+	ZoomLevel zoom = ZOOM_LVL_NORMAL;
 
-	DEBUG(sprite, 9, "Load sprite %d", id);
+	if (_cur_dpi) {
+		zoom = ZoomLevel(_cur_dpi->zoom);
+	}	
 
 	if (!SpriteExists(id)) {
 		DEBUG(sprite, 1, "Tried to load non-existing sprite #%d. Probable cause: Wrong/missing NewGRFs", id);
@@ -140,14 +149,30 @@
 #ifdef WITH_PNG
 		/* Try loading 32bpp graphics in case we are 32bpp output */
 		SpriteLoaderPNG sprite_loader;
-		SpriteLoader::Sprite sprite;
-
-		if (sprite_loader.LoadSprite(&sprite, file_slot, sc->id)) {
-			sc->ptr = BlitterFactoryBase::GetCurrentBlitter()->Encode(&sprite, &AllocSprite);
+		SpriteLoader::Sprite sprite, dst_sprite;
+		ZoomLevel zoom_idx = (zoom > ZOOM_LVL_NORMAL ? ZOOM_LVL_NORMAL : zoom);
+		bool found = false;
+		do {
+			found = sprite_loader.LoadSprite(&sprite, sc->file_slot,
+									 sc->id, zoom_idx);
+			zoom_idx--;											
+		} while ( !found && (zoom_idx >= ZOOM_LVL_MIN ) );
+		if (found) {
+			zoom_idx++;
+			if (zoom > zoom_idx)	{
+				Blitter_32bppOptimized *blitter = (Blitter_32bppOptimized *)BlitterFactoryBase::GetCurrentBlitter();
+				do {
+					blitter->RescaleSpriteHalfSize(&sprite, &dst_sprite, true);
+					free(sprite.data);
+					sprite = dst_sprite;
+					zoom_idx++;
+				} while (zoom_idx < zoom);
+			}
+			sc->ptr[zoom] = BlitterFactoryBase::GetCurrentBlitter()->Encode(&sprite, &AllocSprite);
 			free(sprite.data);
+			return sc->ptr[zoom];
+		}
 
-			return sc->ptr;
-		}
 		/* If the PNG couldn't be loaded, fall back to 8bpp grfs */
 #else
 		static bool show_once = true;
@@ -175,10 +200,10 @@
 
 		byte *dest = (byte *)AllocSprite(num);
 
-		sc->ptr = dest;
+		sc->ptr[zoom] = dest;
 		FioReadBlock(dest, num);
 
-		return sc->ptr;
+		return sc->ptr[zoom];
 	}
 	/* Ugly hack to work around the problem that the old landscape
 	 *  generator assumes that those sprites are stored uncompressed in
@@ -197,7 +222,7 @@
 
 		num = width * height;
 		sprite = (Sprite *)AllocSprite(sizeof(*sprite) + num);
-		sc->ptr = sprite;
+		sc->ptr[zoom] = sprite;
 		sprite->height = height;
 		sprite->width  = width;
 		sprite->x_offs = FioReadWord();
@@ -217,7 +242,7 @@
 			}
 		}
 
-		return sc->ptr;
+		return sc->ptr[zoom];
 	}
 
 	if (!real_sprite) {
@@ -227,14 +252,39 @@
 	}
 
 	SpriteLoaderGrf sprite_loader;
-	SpriteLoader::Sprite sprite;
+	SpriteLoader::Sprite sprite, dst_sprite;
 
-	if (!sprite_loader.LoadSprite(&sprite, file_slot, file_pos)) return NULL;
+	if (!sprite_loader.LoadSprite(&sprite, file_slot, file_pos,ZOOM_LVL_NORMAL)) {
+		return NULL;
+	}
+
+	Blitter_32bppOptimized *blitter = (Blitter_32bppOptimized *)BlitterFactoryBase::GetCurrentBlitter();
+	if (BlitterFactoryBase::GetCurrentBlitter()->GetScreenDepth() == 32) {
+		blitter->FillRGBFromPalette(&sprite);
+	}
+	if (zoom < ZOOM_LVL_NORMAL) {
+		ZoomLevel zoom_idx = zoom;
+		do {
+			blitter->RescaleSpriteDoubleSize(&sprite, &dst_sprite);
+			free(sprite.data);
+			sprite = dst_sprite;
+			zoom_idx++;
+		} while (zoom_idx < ZOOM_LVL_NORMAL);
+	}
+	if (zoom > ZOOM_LVL_NORMAL) {
+		ZoomLevel zoom_idx = ZOOM_LVL_NORMAL;
+		do {
+			blitter->RescaleSpriteHalfSize(&sprite, &dst_sprite, true);
+			free(sprite.data);
+			sprite = dst_sprite;
+			zoom_idx++;
+		} while (zoom_idx < zoom);
+	}
 	if (id == 142) sprite.height = 10; // Compensate for a TTD bug
-	sc->ptr = BlitterFactoryBase::GetCurrentBlitter()->Encode(&sprite, &AllocSprite);
+	sc->ptr[zoom] = blitter->Encode(&sprite, &AllocSprite);
 	free(sprite.data);
 
-	return sc->ptr;
+	return sc->ptr[zoom];
 }
 
 
@@ -252,7 +302,12 @@
 	sc = AllocateSpriteCache(load_index);
 	sc->file_slot = file_slot;
 	sc->file_pos = file_pos;
-	sc->ptr = NULL;
+	sc->ptr[ZOOM_LVL_IN_4X] = NULL;
+	sc->ptr[ZOOM_LVL_IN_2X] = NULL;
+  	sc->ptr[ZOOM_LVL_NORMAL] = NULL;
+  	sc->ptr[ZOOM_LVL_OUT_2X] = NULL;
+	sc->ptr[ZOOM_LVL_OUT_4X] = NULL;
+	sc->ptr[ZOOM_LVL_OUT_8X] = NULL;
 	sc->lru = 0;
 	sc->id = file_sprite_id;
 
@@ -264,10 +319,12 @@
 {
 	SpriteCache *scnew = AllocateSpriteCache(new_spr); // may reallocate: so put it first
 	SpriteCache *scold = GetSpriteCache(old_spr);
+	ZoomLevel zoom;
 
 	scnew->file_slot = scold->file_slot;
 	scnew->file_pos = scold->file_pos;
-	scnew->ptr = NULL;
+	zoom = ZoomLevel(_cur_dpi->zoom);
+	scnew->ptr[zoom] = NULL;
 	scnew->id = scold->id;
 }
 
@@ -284,9 +341,8 @@
 	uint32 tot_size = 0;
 	MemBlock* s;
 
-	for (s = _spritecache_ptr; s->size != 0; s = NextBlock(s)) {
+	for (s = _spritecache_ptr; s->size != 0; s = NextBlock(s)) 
 		if (!(s->size & S_FREE_MASK)) tot_size += s->size;
-	}
 
 	return tot_size;
 }
@@ -294,6 +350,7 @@
 
 void IncreaseSpriteLRU()
 {
+	ZoomLevel zoom;
 	/* Increase all LRU values */
 	if (_sprite_lru_counter > 16384) {
 		SpriteID i;
@@ -302,7 +359,8 @@
 
 		for (i = 0; i != _spritecache_items; i++) {
 			SpriteCache *sc = GetSpriteCache(i);
-			if (sc->ptr != NULL) {
+			zoom = ZoomLevel(_cur_dpi->zoom);
+			if (sc->ptr[zoom] != NULL) {
 				if (sc->lru >= 0) {
 					sc->lru = -1;
 				} else if (sc->lru != -32768) {
@@ -325,6 +383,7 @@
 static void CompactSpriteCache()
 {
 	MemBlock *s;
+	ZoomLevel	zoom;
 
 	DEBUG(sprite, 3, "Compacting sprite cache, inuse=%d", GetSpriteCacheUsage());
 
@@ -341,11 +400,16 @@
 			if (next->size == 0) break;
 
 			/* Locate the sprite belonging to the next pointer. */
-			for (i = 0; GetSpriteCache(i)->ptr != next->data; i++) {
-				assert(i != _spritecache_items);
+			bool found = false;
+			for (zoom = ZOOM_LVL_MIN;
+				  (zoom < ZOOM_LVL_END) && (!found);
+				  zoom = ZoomLevel(zoom + 1)) {
+				for (i = 0; i < _spritecache_items && !found; i++) {
+					found = (GetSpriteCache(i)->ptr[zoom] == next->data);
+				}
 			}
-
-			GetSpriteCache(i)->ptr = s->data; // Adjust sprite array entry
+			assert(found);
+			GetSpriteCache(i - 1)->ptr[zoom - 1] = s->data; // Adjust sprite array entry
 			/* Swap this and the next block */
 			temp = *s;
 			memmove(s, next, next->size);
@@ -367,16 +431,21 @@
 	SpriteID i;
 	uint best = UINT_MAX;
 	MemBlock* s;
-	int cur_lru;
+	int16 cur_lru;
+	ZoomLevel zoom;
 
 	DEBUG(sprite, 3, "DeleteEntryFromSpriteCache, inuse=%d", GetSpriteCacheUsage());
 
-	cur_lru = 0xffff;
+	cur_lru = -1;
 	for (i = 0; i != _spritecache_items; i++) {
 		SpriteCache *sc = GetSpriteCache(i);
-		if (sc->ptr != NULL && sc->lru < cur_lru) {
-			cur_lru = sc->lru;
-			best = i;
+		if (sc->lru < cur_lru) {
+			for (zoom = ZOOM_LVL_MIN; zoom < ZOOM_LVL_END; zoom ++) {
+				if (sc->ptr[zoom]) {
+					cur_lru = sc->lru;
+					best = i;
+				}
+			}
 		}
 	}
 
@@ -384,19 +453,24 @@
 	 * This shouldn't really happen, unless all sprites are locked. */
 	if (best == (uint)-1) error("Out of sprite memory");
 
+	SpriteCache *sc = GetSpriteCache(best);
 	/* Mark the block as free (the block must be in use) */
-	s = (MemBlock*)GetSpriteCache(best)->ptr - 1;
-	assert(!(s->size & S_FREE_MASK));
-	s->size |= S_FREE_MASK;
-	GetSpriteCache(best)->ptr = NULL;
+	for (zoom = ZOOM_LVL_MIN ; zoom < ZOOM_LVL_END ; zoom = ZoomLevel(zoom + 1)) {
+		if (sc->ptr[zoom]) {
+			s = (MemBlock*)sc->ptr[zoom] - 1;
+			assert(!(s->size & S_FREE_MASK));
+			s->size |= S_FREE_MASK;
+			sc->ptr[zoom] = NULL;
 
-	/* And coalesce adjacent free blocks */
-	for (s = _spritecache_ptr; s->size != 0; s = NextBlock(s)) {
-		if (s->size & S_FREE_MASK) {
-			while (NextBlock(s)->size & S_FREE_MASK) {
-				s->size += NextBlock(s)->size & ~S_FREE_MASK;
+			/* And coalesce adjacent free blocks */
+			for (s = _spritecache_ptr; s->size != 0; s = NextBlock(s)) {
+				if (s->size & S_FREE_MASK) {
+					while (NextBlock(s)->size & S_FREE_MASK) {
+						s->size += NextBlock(s)->size & ~S_FREE_MASK;
+					}
+				}
 			}
-		}
+		}	
 	}
 }
 
@@ -407,7 +481,7 @@
 	/* Align this to an uint32 boundary. This also makes sure that the 2 least
 	 * bits are not used, so we could use those for other things. */
 	mem_req = Align(mem_req, sizeof(uint32));
-
+	DEBUG(sprite, 3, "AllocSprite, memreq=%d", mem_req);
 	for (;;) {
 		MemBlock* s;
 
@@ -442,6 +516,7 @@
 {
 	SpriteCache *sc;
 	void* p;
+	ZoomLevel zoom;
 
 	assert(sprite < _spritecache_items);
 
@@ -450,8 +525,9 @@
 	/* Update LRU */
 	sc->lru = ++_sprite_lru_counter;
 
-	p = sc->ptr;
-
+ 	zoom = ZoomLevel(_cur_dpi->zoom);
+ 	p = sc->ptr[zoom];
+	
 	/* Load the sprite, if it is not loaded, yet */
 	if (p == NULL) p = ReadSprite(sc, sprite, real_sprite);
 
@@ -462,7 +538,7 @@
 void GfxInitSpriteMem()
 {
 	/* initialize sprite cache heap */
-	if (_spritecache_ptr == NULL) _spritecache_ptr = (MemBlock*)MallocT<byte>(_sprite_cache_size * 1024 * 1024);
+	if (_spritecache_ptr == NULL) _spritecache_ptr = (MemBlock*)malloc(_sprite_cache_size * 1024 * 1024);
 
 	/* A big free block */
 	_spritecache_ptr->size = ((_sprite_cache_size * 1024 * 1024) - sizeof(MemBlock)) | S_FREE_MASK;
@@ -473,6 +549,5 @@
 	free(_spritecache);
 	_spritecache_items = 0;
 	_spritecache = NULL;
-
 	_compact_cache_counter = 0;
 }
Index: src/tunnelbridge_cmd.cpp
===================================================================
--- src/tunnelbridge_cmd.cpp	(revision 12652)
+++ src/tunnelbridge_cmd.cpp	(working copy)
@@ -1249,10 +1249,10 @@
 	}
 }
 
-
-static const byte _tunnel_fractcoord_1[4]    = {0x8E, 0x18, 0x81, 0xE8};
-static const byte _tunnel_fractcoord_2[4]    = {0x81, 0x98, 0x87, 0x38};
-static const byte _tunnel_fractcoord_3[4]    = {0x82, 0x88, 0x86, 0x48};
+/** clip coordinate                              NE    SE     SW    NW*/
+static const byte _tunnel_fractcoord_1[4]    = {0x8A, 0x58, 0x84, 0x88};
+/**  hide coordinate */
+static const byte _tunnel_fractcoord_2[4]    = {0x84, 0xD8, 0x8F, 0x38};
 static const byte _exit_tunnel_track[4]      = {1, 2, 1, 2};
 
 /** Get the trackdir of the exit of a tunnel */
@@ -1265,7 +1265,9 @@
 static const byte _tunnel_fractcoord_5[4]    = {0x92, 0x89, 0x58, 0x25};
 static const byte _tunnel_fractcoord_6[4]    = {0x92, 0x89, 0x56, 0x45};
 static const byte _tunnel_fractcoord_7[4]    = {0x52, 0x85, 0x96, 0x49};
-
+static const VehStatus  _clip_part[4] = {VS_CLIP_RIGHT, VS_CLIP_RIGHT,
+													  VS_CLIP_LEFT, VS_CLIP_LEFT};
+													  
 static VehicleEnterTileStatus VehicleEnter_TunnelBridge(Vehicle *v, TileIndex tile, int x, int y)
 {
 	int z = GetSlopeZ(x, y) - v->z_pos;
@@ -1283,11 +1285,14 @@
 			vdir = DirToDiagDir(v->direction);
 
 			if (v->u.rail.track != TRACK_BIT_WORMHOLE && dir == vdir) {
-				if (IsFrontEngine(v) && fc == _tunnel_fractcoord_1[dir]) {
-					if (!PlayVehicleSound(v, VSE_TUNNEL) && RailVehInfo(v->engine_type)->engclass == 0) {
-						SndPlayVehicleFx(SND_05_TRAIN_THROUGH_TUNNEL, v);
-					}
-					return VETSB_CONTINUE;
+				if (fc == _tunnel_fractcoord_1[dir]) {
+					if (IsFrontEngine(v) ) {
+						if (!PlayVehicleSound(v, VSE_TUNNEL) && RailVehInfo(v->engine_type)->engclass == 0) {
+							SndPlayVehicleFx(SND_05_TRAIN_THROUGH_TUNNEL, v);
+						}
+					}	
+					v->vehstatus |= _clip_part[dir];
+					return VETSB_ENTERED_WORMHOLE;
 				}
 				if (fc == _tunnel_fractcoord_2[dir]) {
 					v->tile = tile;
@@ -1297,13 +1302,20 @@
 				}
 			}
 
-			if (dir == ReverseDiagDir(vdir) && fc == _tunnel_fractcoord_3[dir] && z == 0) {
+			if (dir == ReverseDiagDir(vdir)  && z == 0) {
 				/* We're at the tunnel exit ?? */
-				v->tile = tile;
-				v->u.rail.track = (TrackBits)_exit_tunnel_track[dir];
-				assert(v->u.rail.track);
-				v->vehstatus &= ~VS_HIDDEN;
-				return VETSB_ENTERED_WORMHOLE;
+				if (fc == _tunnel_fractcoord_2[dir]) {
+					v->tile = tile;
+					v->u.rail.track = (TrackBits)_exit_tunnel_track[dir];
+					assert(v->u.rail.track);
+					v->vehstatus &= ~(VS_HIDDEN | VS_CLIP_LEFT | VS_CLIP_RIGHT);
+					v->vehstatus |= _clip_part[dir];
+					return VETSB_ENTERED_WORMHOLE;
+				}
+				if (fc == _tunnel_fractcoord_1[dir]) {
+					v->vehstatus &= ~(VS_CLIP_LEFT | VS_CLIP_RIGHT);
+					return VETSB_ENTERED_WORMHOLE;
+				}
 			}
 		} else if (v->type == VEH_ROAD) {
 			fc = (x & 0xF) + (y << 4);
Index: src/spritecache.h
===================================================================
--- src/spritecache.h	(revision 12652)
+++ src/spritecache.h	(working copy)
@@ -7,8 +7,9 @@
 
 #include "gfx_type.h"
 
+
 struct Sprite {
-	byte height;
+	uint16 height;
 	uint16 width;
 	int16 x_offs;
 	int16 y_offs;
Index: src/texteff.cpp
===================================================================
--- src/texteff.cpp	(revision 12652)
+++ src/texteff.cpp	(working copy)
@@ -386,6 +386,35 @@
 void DrawTextEffects(DrawPixelInfo *dpi)
 {
 	switch (dpi->zoom) {
+		case ZOOM_LVL_IN_4X:
+			for (TextEffectID i = 0; i < _num_text_effects; i++) {
+				TextEffect *te = &_text_effect_list[i];
+				if (te->string_id != INVALID_STRING_ID &&
+						dpi->left <= te->right &&
+						dpi->top  <= te->bottom &&
+						dpi->left + dpi->width  > te->x &&
+						dpi->top  + dpi->height > te->y) {
+					if (te->mode == TE_RISING || (_patches.loading_indicators && !IsTransparencySet(TO_LOADING))) {
+						AddStringToDraw(te->x, te->y, te->string_id, te->params_1, te->params_2);
+					}
+				}
+			}
+			break;
+		case ZOOM_LVL_IN_2X:
+			for (TextEffectID i = 0; i < _num_text_effects; i++) {
+				TextEffect *te = &_text_effect_list[i];
+				if (te->string_id != INVALID_STRING_ID &&
+						dpi->left <= te->right &&
+						dpi->top  <= te->bottom &&
+						dpi->left + dpi->width  > te->x &&
+						dpi->top  + dpi->height > te->y) {
+					if (te->mode == TE_RISING || (_patches.loading_indicators && !IsTransparencySet(TO_LOADING))) {
+						AddStringToDraw(te->x, te->y, te->string_id, te->params_1, te->params_2);
+					}
+				}
+			}
+			break;
+
 		case ZOOM_LVL_NORMAL:
 			for (TextEffectID i = 0; i < _num_text_effects; i++) {
 				TextEffect *te = &_text_effect_list[i];
Index: src/window.cpp
===================================================================
--- src/window.cpp	(revision 12652)
+++ src/window.cpp	(working copy)
@@ -263,7 +263,8 @@
 void DrawOverlappedWindowForAll(int left, int top, int right, int bottom)
 {
 	Window* const *wz;
-	DrawPixelInfo bk;
+	DrawPixelInfo bk, *old_dpi;
+	old_dpi = _cur_dpi;
 	_cur_dpi = &bk;
 
 	FOR_ALL_WINDOWS(wz) {
@@ -275,6 +276,7 @@
 			DrawOverlappedWindow(wz, left, top, right, bottom);
 		}
 	}
+	_cur_dpi = old_dpi;
 }
 
 /**
Index: src/landscape.cpp
===================================================================
--- src/landscape.cpp	(revision 12652)
+++ src/landscape.cpp	(working copy)
@@ -385,7 +385,7 @@
 		if (!IsNonContinuousFoundation(f)) {
 			/* Lower part of foundation */
 			AddSortableSpriteToDraw(
-				leveled_base + (ti->tileh & ~SLOPE_STEEP), PAL_NONE, ti->x, ti->y, 16, 16, 7, ti->z
+				leveled_base + (ti->tileh & ~SLOPE_STEEP), PAL_NONE, ti->x, ti->y, 16, 16, 1, ti->z
 			);
 		}
 
@@ -396,7 +396,7 @@
 			/* inclined foundation */
 			byte inclined = highest_corner * 2 + (f == FOUNDATION_INCLINED_Y ? 1 : 0);
 
-			AddSortableSpriteToDraw(inclined_base + inclined, PAL_NONE, ti->x, ti->y, 16, 16, 1, ti->z);
+			AddSortableSpriteToDraw(inclined_base + inclined, PAL_NONE, ti->x, ti->y, 16, 16, 1, ti->z, false, 0, 0,-11);
 			OffsetGroundSprite(31, 9);
 		} else if (f == FOUNDATION_STEEP_LOWER) {
 			/* one corner raised */
@@ -406,13 +406,13 @@
 			int x_bb = (((highest_corner == CORNER_W) || (highest_corner == CORNER_S)) ? 8 : 0);
 			int y_bb = (((highest_corner == CORNER_S) || (highest_corner == CORNER_E)) ? 8 : 0);
 
-			AddSortableSpriteToDraw(halftile_base + highest_corner, PAL_NONE, ti->x + x_bb, ti->y + y_bb, 8, 8, 7, ti->z + TILE_HEIGHT);
+			AddSortableSpriteToDraw(halftile_base + highest_corner, PAL_NONE, ti->x + x_bb, ti->y + y_bb, 8, 8, 1, ti->z + TILE_HEIGHT);
 			OffsetGroundSprite(31, 9);
 		}
 	} else {
 		if (IsLeveledFoundation(f)) {
 			/* leveled foundation */
-			AddSortableSpriteToDraw(leveled_base + ti->tileh, PAL_NONE, ti->x, ti->y, 16, 16, 7, ti->z);
+			AddSortableSpriteToDraw(leveled_base + ti->tileh, PAL_NONE, ti->x, ti->y, 16, 16, 1, ti->z);
 			OffsetGroundSprite(31, 1);
 		} else if (IsNonContinuousFoundation(f)) {
 			/* halftile foundation */
@@ -420,7 +420,7 @@
 			int x_bb = (((halftile_corner == CORNER_W) || (halftile_corner == CORNER_S)) ? 8 : 0);
 			int y_bb = (((halftile_corner == CORNER_S) || (halftile_corner == CORNER_E)) ? 8 : 0);
 
-			AddSortableSpriteToDraw(halftile_base + halftile_corner, PAL_NONE, ti->x + x_bb, ti->y + y_bb, 8, 8, 7, ti->z);
+			AddSortableSpriteToDraw(halftile_base + halftile_corner, PAL_NONE, ti->x + x_bb, ti->y + y_bb, 8, 8, 1, ti->z);
 			OffsetGroundSprite(31, 9);
 		} else if (IsSpecialRailFoundation(f)) {
 			/* anti-zig-zag foundation */
@@ -438,7 +438,7 @@
 			/* inclined foundation */
 			byte inclined = GetHighestSlopeCorner(ti->tileh) * 2 + (f == FOUNDATION_INCLINED_Y ? 1 : 0);
 
-			AddSortableSpriteToDraw(inclined_base + inclined, PAL_NONE, ti->x, ti->y, 16, 16, 1, ti->z);
+			AddSortableSpriteToDraw(inclined_base + inclined, PAL_NONE, ti->x, ti->y, 16, 16, 1, ti->z, false, 0, 0, -11);
 			OffsetGroundSprite(31, 9);
 		}
 		ti->z += ApplyFoundationToSlope(f, &ti->tileh);
Index: src/roadveh_cmd.cpp
===================================================================
--- src/roadveh_cmd.cpp	(revision 12652)
+++ src/roadveh_cmd.cpp	(working copy)
@@ -566,14 +566,14 @@
 {
 #define MKIT(a, b, c, d) ((a & 0xFF) << 24) | ((b & 0xFF) << 16) | ((c & 0xFF) << 8) | ((d & 0xFF) << 0)
 	static const uint32 _delta_xy_table[8] = {
-		MKIT(3, 3, -1, -1),
-		MKIT(3, 7, -1, -3),
-		MKIT(3, 3, -1, -1),
-		MKIT(7, 3, -3, -1),
-		MKIT(3, 3, -1, -1),
-		MKIT(3, 7, -1, -3),
-		MKIT(3, 3, -1, -1),
-		MKIT(7, 3, -3, -1),
+		MKIT(3, 3, -1, -1),   // N
+		MKIT(3, 14, -1, -3),   // NE
+		MKIT(3, 3, -1, -1),   // E
+		MKIT(7, 3, -3, -1),   // SE
+		MKIT(3, 3, -1, -1),   // S
+		MKIT(3, 14, -1, -3),   // SW
+		MKIT(3, 3, -1, -1),   // W
+		MKIT(7, 3, -3, -1),   // NW
 	};
 #undef MKIT
 
Index: src/zoom_type.h
===================================================================
--- src/zoom_type.h	(revision 12652)
+++ src/zoom_type.h	(working copy)
@@ -9,8 +9,10 @@
 
 enum ZoomLevel {
 	/* Our possible zoom-levels */
-	ZOOM_LVL_BEGIN  = 0,
-	ZOOM_LVL_NORMAL = 0,
+	ZOOM_LVL_BEGIN = 0,
+	ZOOM_LVL_IN_4X = 0,
+	ZOOM_LVL_IN_2X,  
+	ZOOM_LVL_NORMAL,
 	ZOOM_LVL_OUT_2X,
 	ZOOM_LVL_OUT_4X,
 	ZOOM_LVL_OUT_8X,
@@ -29,7 +31,7 @@
 
 	ZOOM_LVL_DETAIL   = ZOOM_LVL_OUT_2X, ///< All zoomlevels below or equal to this, will result in details on the screen, like road-work, ...
 
-	ZOOM_LVL_MIN      = ZOOM_LVL_NORMAL,
+	ZOOM_LVL_MIN      = ZOOM_LVL_BEGIN,
 	ZOOM_LVL_MAX      = ZOOM_LVL_OUT_8X,
 };
 DECLARE_POSTFIX_INCREMENT(ZoomLevel)
Index: src/vehicle.cpp
===================================================================
--- src/vehicle.cpp	(revision 12652)
+++ src/vehicle.cpp	(working copy)
@@ -761,6 +761,12 @@
 	return CommandCost(expense_type, (EngInfo(engine_type)->refit_cost * base_cost) >> 10);
 }
 
+SubSprite sub[2] = {{-31,   -31, 64, 30},    /* CLIP_RIGHT */
+						  {-31,   -31, 64, 30}};   /* CLIP_LEFT  */
+						  //   N  NE  E  SE  S  SW  W  NW
+int clip_offset_l[8] = { 0, -8, 0, 9, 0, -8, 0, 9};						  
+int clip_offset_r[8] = { 0, -1, 0,  8, 0, -1, 0,  8};						  
+
 static void DoDrawVehicle(const Vehicle *v)
 {
 	SpriteID image = v->cur_image;
@@ -772,8 +778,27 @@
 		pal = PAL_NONE;
 	}
 
-	AddSortableSpriteToDraw(image, pal, v->x_pos + v->x_offs, v->y_pos + v->y_offs,
-		v->x_extent, v->y_extent, v->z_extent, v->z_pos, (v->vehstatus & VS_SHADOW) != 0);
+   if ((v->vehstatus & VS_SHADOW) != 0)
+   {
+      SetBit(image, PALETTE_MODIFIER_SHADOW);
+   }
+   if ((v->vehstatus & (VS_CLIP_LEFT | VS_CLIP_RIGHT)) != 0){
+		if (v->vehstatus & VS_CLIP_RIGHT){
+			sub[0].right = clip_offset_r[v->direction] 
+								+ ((v->x_pos & 0xF) - (v->y_pos & 0xF))<<1;
+		}
+		if (v->vehstatus & VS_CLIP_LEFT){
+			sub[1].left =  clip_offset_l[v->direction] 
+								+ ((v->x_pos & 0xF) - (v->y_pos & 0xF))<<1;
+		}
+		AddSortableSpriteToDraw(image, pal, v->x_pos + v->x_offs, v->y_pos + v->y_offs,
+			v->x_extent, v->y_extent, v->z_extent, v->z_pos, false, 
+			0, 0, 0, (const SubSprite *)&sub[(v->vehstatus>>8)-1]);
+	}
+	else{
+		AddSortableSpriteToDraw(image, pal, v->x_pos + v->x_offs, v->y_pos + v->y_offs,
+			v->x_extent, v->y_extent, v->z_extent, v->z_pos, false);	
+	}
 }
 
 void ViewportAddVehicles(DrawPixelInfo *dpi)
@@ -810,11 +835,7 @@
 			const Vehicle *v = _vehicle_position_hash[x + y]; // already masked & 0xFFF
 
 			while (v != NULL) {
-				if (!(v->vehstatus & VS_HIDDEN) &&
-						l <= v->right_coord &&
-						t <= v->bottom_coord &&
-						r >= v->left_coord &&
-						b >= v->top_coord) {
+				if (!(v->vehstatus & VS_HIDDEN) ) { 
 					DoDrawVehicle(v);
 				}
 				v = v->next_hash;
@@ -1441,8 +1462,8 @@
 			 (uint)(y -= vp->top) >= (uint)vp->height)
 				return NULL;
 
-	x = ScaleByZoom(x, vp->zoom) + vp->virtual_left;
-	y = ScaleByZoom(y, vp->zoom) + vp->virtual_top;
+	x = ScaleByZoom(x+ vp->virtual_left, vp->zoom) ;
+	y = ScaleByZoom(y+ vp->virtual_top, vp->zoom) ;
 
 	FOR_ALL_VEHICLES(v) {
 		if ((v->vehstatus & (VS_HIDDEN|VS_UNCLICKABLE)) == 0 &&
Index: src/viewport.cpp
===================================================================
--- src/viewport.cpp	(revision 12652)
+++ src/viewport.cpp	(working copy)
@@ -106,7 +106,7 @@
 struct ParentSpriteToDraw {
 	SpriteID image;                 ///< sprite to draw
 	SpriteID pal;                   ///< palette to use
-	const SubSprite *sub;           ///< only draw a rectangular part of the sprite
+	SubSprite sub;           ///< only draw a rectangular part of the sprite
 
 	int32 x;                        ///< screen X coordinate of sprite
 	int32 y;                        ///< screen Y coordinate of sprite
@@ -143,7 +143,7 @@
 
 struct ViewportDrawer {
 	DrawPixelInfo dpi;
-
+	const ViewPort *vp;
 	byte *spritelist_mem;
 	const byte *eof_spritelist_mem;
 
@@ -316,14 +316,13 @@
 	int i;
 	int left, top, width, height;
 
-	vp->virtual_left = x;
-	vp->virtual_top = y;
+	vp->virtual_left = UnScaleByZoomLower(x, vp->zoom);
+	vp->virtual_top = UnScaleByZoomLower(y, vp->zoom);
 
 	/* viewport is bound to its left top corner, so it must be rounded down (UnScaleByZoomLower)
 	 * else glitch described in FS#1412 will happen (offset by 1 pixel with zoom level > NORMAL)
 	 */
-	old_left = UnScaleByZoomLower(old_left, vp->zoom);
-	old_top = UnScaleByZoomLower(old_top, vp->zoom);
+
 	x = UnScaleByZoomLower(x, vp->zoom);
 	y = UnScaleByZoomLower(y, vp->zoom);
 
@@ -386,9 +385,8 @@
 				return pt;
 	}
 
-	x = (ScaleByZoom(x, vp->zoom) + vp->virtual_left) >> 2;
-	y = (ScaleByZoom(y, vp->zoom) + vp->virtual_top) >> 1;
-
+	x = (ScaleByZoom(x + vp->virtual_left, vp->zoom) ) >> 2;
+	y = (ScaleByZoom(y + vp->virtual_top, vp->zoom) ) >> 1;
 	a = y-x;
 	b = y+x;
 
@@ -606,15 +604,19 @@
 	Point pt = RemapCoords(x, y, z);
 	const Sprite* spr = GetSprite(image & SPRITE_MASK);
 
-	if (pt.x + spr->x_offs >= vd->dpi.left + vd->dpi.width ||
-			pt.x + spr->x_offs + spr->width <= vd->dpi.left ||
-			pt.y + spr->y_offs >= vd->dpi.top + vd->dpi.height ||
-			pt.y + spr->y_offs + spr->height <= vd->dpi.top)
+	int xu = UnScaleByZoom(pt.x, vd->dpi.zoom);
+	int yu = UnScaleByZoom(pt.y, vd->dpi.zoom);
+
+	if (xu + spr->x_offs >= vd->vp->virtual_left + vd->vp->width ||
+		 xu + spr->x_offs + spr->width <= vd->vp->virtual_left ||
+		 yu + spr->y_offs >= vd->vp->virtual_top + vd->vp->height ||
+		 yu + spr->y_offs + spr->height <= vd->vp->virtual_top)
 		return;
 
 	AddChildSpriteScreen(image, pal, pt.x - vd->parent_list[-1]->left, pt.y - vd->parent_list[-1]->top, false, sub);
 }
 
+
 /** Draw a (transparent) sprite at given coordinates with a given bounding box.
  * The bounding box extends from (x + bb_offset_x, y + bb_offset_y, z + bb_offset_z) to (x + w - 1, y + h - 1, z + dz - 1), both corners included.
  * Bounding boxes with bb_offset_x == w or bb_offset_y == h or bb_offset_z == dz are allowed and produce thin slices.
@@ -651,7 +653,6 @@
 	/* make the sprites transparent with the right palette */
 	if (transparent) {
 		SetBit(image, PALETTE_MODIFIER_TRANSPARENT);
-		pal = PALETTE_TO_TRANSPARENT;
 	}
 
 	if (vd->combine_sprites == 2) {
@@ -684,31 +685,37 @@
 
 	/* Compute screen extents of sprite */
 	if (image == SPR_EMPTY_BOUNDING_BOX) {
-		left = ps->left = RemapCoords(x + w          , y + bb_offset_y, z + bb_offset_z).x;
-		right           = RemapCoords(x + bb_offset_x, y + h          , z + bb_offset_z).x + 1;
-		top  = ps->top  = RemapCoords(x + bb_offset_x, y + bb_offset_y, z + dz         ).y;
-		bottom          = RemapCoords(x + w          , y + h          , z + bb_offset_z).y + 1;
+		left = ps->left = RemapCoords(x + w				, y + bb_offset_y, z + bb_offset_z).x;
+		right				 = RemapCoords(x + bb_offset_x, y + h			  , z + bb_offset_z).x + 1;
+		top  = ps->top  = RemapCoords(x + bb_offset_x, y + bb_offset_y, z + dz	  		 ).y;
+		bottom			 = RemapCoords(x + w				, y + h			  , z + bb_offset_z).y + 1;
 	} else {
 		const Sprite *spr = GetSprite(image & SPRITE_MASK);
-		left = ps->left = (pt.x += spr->x_offs);
-		right           = (pt.x +  spr->width );
-		top  = ps->top  = (pt.y += spr->y_offs);
-		bottom          = (pt.y +  spr->height);
+		int x_offs, y_offs,swidth, sheight;
+
+		x_offs = ScaleByZoom(spr->x_offs, vd->vp->zoom);
+		y_offs = ScaleByZoom(spr->y_offs, vd->vp->zoom);
+		swidth = ScaleByZoom(spr->width, vd->vp->zoom);
+		sheight = ScaleByZoom(spr->height, vd->vp->zoom);
+		left = ps->left = (pt.x += x_offs);
+		right				 = (pt.x +  swidth );
+		top  = ps->top  = (pt.y += y_offs);
+		bottom			 = (pt.y +  sheight);
 	}
 
 	if (_draw_bounding_boxes && (image != SPR_EMPTY_BOUNDING_BOX)) {
 		/* Compute maximal extents of sprite and it's bounding box */
-		left   = min(left  , RemapCoords(x + w          , y + bb_offset_y, z + bb_offset_z).x);
-		right  = max(right , RemapCoords(x + bb_offset_x, y + h          , z + bb_offset_z).x + 1);
-		top    = min(top   , RemapCoords(x + bb_offset_x, y + bb_offset_y, z + dz         ).y);
-		bottom = max(bottom, RemapCoords(x + w          , y + h          , z + bb_offset_z).y + 1);
+		left	 = min(left  , RemapCoords(x + w				, y + bb_offset_y, z + bb_offset_z).x);
+		right  = max(right , RemapCoords(x + bb_offset_x, y + h			  , z + bb_offset_z).x + 1);
+		top	 = min(top	 , RemapCoords(x + bb_offset_x, y + bb_offset_y, z + dz			 ).y);
+		bottom = max(bottom, RemapCoords(x + w		 		, y + h			  , z + bb_offset_z).y + 1);
 	}
 
 	/* Do not add the sprite to the viewport, if it is outside */
-	if (left   >= vd->dpi.left + vd->dpi.width ||
-	    right  <= vd->dpi.left                 ||
-	    top    >= vd->dpi.top + vd->dpi.height ||
-	    bottom <= vd->dpi.top) {
+	if (UnScaleByZoom(left, vd->vp->zoom)	 >= vd->vp->virtual_left + vd->vp->width ||
+		 UnScaleByZoom(right, vd->vp->zoom)  <= vd->vp->virtual_left ||
+		 UnScaleByZoom(top, vd->vp->zoom)	 >= vd->vp->virtual_top + vd->vp->height  ||
+		 UnScaleByZoom(bottom, vd->vp->zoom) <= vd->vp->virtual_top) {
 		return;
 	}
 
@@ -716,7 +723,18 @@
 
 	ps->image = image;
 	ps->pal = pal;
-	ps->sub = sub;
+	if (sub) {
+		ps->sub.left = UnScaleByZoom(sub->left, vd->vp->zoom);
+		ps->sub.right = UnScaleByZoom(sub->right, vd->vp->zoom);
+		ps->sub.top = UnScaleByZoom(sub->top, vd->vp->zoom);
+		ps->sub.bottom = UnScaleByZoom(sub->bottom, vd->vp->zoom);
+	}
+	else {
+		ps->sub.left = -1000; 
+		ps->sub.right = 0x7fff;
+		ps->sub.top = -1000;
+		ps->sub.bottom = 0x7fff;
+	}
 	ps->xmin = x + bb_offset_x;
 	ps->xmax = x + max(bb_offset_x, w) - 1;
 
@@ -765,7 +783,6 @@
 	/* make the sprites transparent with the right palette */
 	if (transparent) {
 		SetBit(image, PALETTE_MODIFIER_TRANSPARENT);
-		pal = PALETTE_TO_TRANSPARENT;
 	}
 
 	if (vd->spritelist_mem >= vd->eof_spritelist_mem) {
@@ -789,8 +806,8 @@
 	cs->image = image;
 	cs->pal = pal;
 	cs->sub = sub;
-	cs->x = x;
-	cs->y = y;
+	cs->x = UnScaleByZoom(x, vd->dpi.zoom);
+	cs->y = UnScaleByZoom(y, vd->dpi.zoom);
 	cs->next = NULL;
 }
 
@@ -1011,25 +1028,28 @@
 static void ViewportAddLandscape()
 {
 	ViewportDrawer *vd = _cur_vd;
-	int x, y, width, height;
+	int x, y, x1, y1, width, nof_sprites_drawn;
+	int top, bottom;
 	TileInfo ti;
 	bool direction;
+	Point pt;
 
 	_cur_ti = &ti;
 
-	/* Transform into tile coordinates and round to closest full tile */
-	x = ((vd->dpi.top >> 1) - (vd->dpi.left >> 2)) & ~0xF;
-	y = ((vd->dpi.top >> 1) + (vd->dpi.left >> 2) - 0x10) & ~0xF;
+	x1 = ScaleByZoomLower(vd->vp->virtual_left + vd->dpi.left, vd->vp->zoom)  ;
+	y1 = ScaleByZoomLower(vd->vp->virtual_top + vd->dpi.top, vd->vp->zoom)  ;
 
-	/* determine size of area */
-	{
-		Point pt = RemapCoords(x, y, 241);
-		width = (vd->dpi.left + vd->dpi.width - pt.x + 95) >> 6;
-		height = (vd->dpi.top + vd->dpi.height - pt.y) >> 5 << 1;
-	}
+	x1 = x1 / 4;
+	y1 = y1 / 2;
 
+	x = ((y1-x1) / TILE_SIZE) * TILE_SIZE ;
+	y = ((y1+x1) / TILE_SIZE) * TILE_SIZE - (TILE_SIZE << 1);
+
+	width  = (vd->dpi.width / UnScaleByZoom(64, vd->vp->zoom)) + 4;
+
+	bottom = ScaleByZoom(vd->vp->virtual_top + vd->dpi.top + vd->dpi.height, vd->vp->zoom) + 128;
+	top = ScaleByZoom(vd->vp->virtual_top + vd->dpi.top, vd->vp->zoom) ;
 	assert(width > 0);
-	assert(height > 0);
 
 	direction = false;
 
@@ -1037,7 +1057,7 @@
 		int width_cur = width;
 		int x_cur = x;
 		int y_cur = y;
-
+		nof_sprites_drawn = 0;
 		do {
 			TileType tt;
 
@@ -1060,14 +1080,17 @@
 			y_cur += 0x10;
 			x_cur -= 0x10;
 
-			vd->foundation_part = FOUNDATION_PART_NONE;
-			vd->foundation[0] = NULL;
-			vd->foundation[1] = NULL;
-			vd->last_foundation_child[0] = NULL;
-			vd->last_foundation_child[1] = NULL;
-
-			_tile_type_procs[tt]->draw_tile_proc(&ti);
-			DrawTileSelection(&ti);
+			pt = RemapCoords(ti.x,ti.y,ti.z);
+			if (pt.y < bottom) {
+				vd->foundation_part = FOUNDATION_PART_NONE;
+				vd->foundation[0] = NULL;
+				vd->foundation[1] = NULL;
+				vd->last_foundation_child[0] = NULL;
+				vd->last_foundation_child[1] = NULL;
+				_tile_type_procs[tt]->draw_tile_proc(&ti);
+				DrawTileSelection(&ti);
+				nof_sprites_drawn++;
+			}
 		} while (--width_cur);
 
 		if ((direction ^= 1) != 0) {
@@ -1075,7 +1098,7 @@
 		} else {
 			x += 0x10;
 		}
-	} while (--height);
+	} while (nof_sprites_drawn || (pt.y < top));
 }
 
 
@@ -1093,12 +1116,36 @@
 	bottom = top + dpi->height;
 
 	switch (dpi->zoom) {
+		case ZOOM_LVL_IN_4X:
+			FOR_ALL_TOWNS(t) {
+				if (bottom > t->sign.top &&
+						top	< t->sign.top + 12 &&
+						right > t->sign.left &&
+						left	< t->sign.left + t->sign.width_1) {
+					AddStringToDraw(t->sign.left + 1, t->sign.top + 1,
+						_patches.population_in_label ? STR_TOWN_LABEL_POP : STR_TOWN_LABEL,
+						t->index, t->population);
+				}
+			}
+			break;
+		case ZOOM_LVL_IN_2X:
+			FOR_ALL_TOWNS(t) {
+				if (bottom	 > t->sign.top &&
+						top	 < t->sign.top + 12 &&
+						right  > t->sign.left &&
+						left	 < t->sign.left + t->sign.width_1) {
+					AddStringToDraw(t->sign.left + 1, t->sign.top + 1,
+						_patches.population_in_label ? STR_TOWN_LABEL_POP : STR_TOWN_LABEL,
+						t->index, t->population);
+				}
+			}
+			break;
 		case ZOOM_LVL_NORMAL:
 			FOR_ALL_TOWNS(t) {
 				if (bottom > t->sign.top &&
-						top    < t->sign.top + 12 &&
+						top	 < t->sign.top + 12 &&
 						right  > t->sign.left &&
-						left   < t->sign.left + t->sign.width_1) {
+						left	 < t->sign.left + t->sign.width_1) {
 					AddStringToDraw(t->sign.left + 1, t->sign.top + 1,
 						_patches.population_in_label ? STR_TOWN_LABEL_POP : STR_TOWN_LABEL,
 						t->index, t->population);
@@ -1111,10 +1158,10 @@
 			bottom += 2;
 
 			FOR_ALL_TOWNS(t) {
-				if (bottom > t->sign.top &&
-						top    < t->sign.top + 24 &&
-						right  > t->sign.left &&
-						left   < t->sign.left + t->sign.width_1*2) {
+				if (bottom  > t->sign.top &&
+						top   < t->sign.top + 24 &&
+						right > t->sign.left &&
+						left	< t->sign.left + t->sign.width_1*2) {
 					AddStringToDraw(t->sign.left + 1, t->sign.top + 1,
 						_patches.population_in_label ? STR_TOWN_LABEL_POP : STR_TOWN_LABEL,
 						t->index, t->population);
@@ -1128,10 +1175,10 @@
 			bottom += ScaleByZoom(1, dpi->zoom) + 1;
 
 			FOR_ALL_TOWNS(t) {
-				if (bottom > t->sign.top &&
-						top    < t->sign.top + ScaleByZoom(12, dpi->zoom) &&
+				if (bottom	 > t->sign.top &&
+						top	 < t->sign.top + ScaleByZoom(12, dpi->zoom) &&
 						right  > t->sign.left &&
-						left   < t->sign.left + ScaleByZoom(t->sign.width_2, dpi->zoom)) {
+						left	 < t->sign.left + ScaleByZoom(t->sign.width_2, dpi->zoom)) {
 					AddStringToDraw(t->sign.left + 5, t->sign.top + 1, STR_TOWN_LABEL_TINY_BLACK, t->index, 0);
 					AddStringToDraw(t->sign.left + 1, t->sign.top - 3, STR_TOWN_LABEL_TINY_WHITE, t->index, 0);
 				}
@@ -1169,12 +1216,33 @@
 	bottom = top + dpi->height;
 
 	switch (dpi->zoom) {
+		case ZOOM_LVL_IN_4X:
+			FOR_ALL_STATIONS(st) {
+				if (bottom > st->sign.top &&
+						top	 < st->sign.top + 12 &&
+						right  > st->sign.left &&
+						left	 < st->sign.left + st->sign.width_1) {
+					AddStation(st, STR_305C_0, st->sign.width_1);
+				}
+			}
+			break;
+		case ZOOM_LVL_IN_2X:
+			FOR_ALL_STATIONS(st) {
+				if (bottom > st->sign.top &&
+						top	 < st->sign.top + 12 &&
+						right  > st->sign.left &&
+						left	 < st->sign.left + st->sign.width_1) {
+					AddStation(st, STR_305C_0, st->sign.width_1);
+				}
+			}
+			break;
+
 		case ZOOM_LVL_NORMAL:
 			FOR_ALL_STATIONS(st) {
 				if (bottom > st->sign.top &&
-						top    < st->sign.top + 12 &&
+						top	 < st->sign.top + 12 &&
 						right  > st->sign.left &&
-						left   < st->sign.left + st->sign.width_1) {
+						left	 < st->sign.left + st->sign.width_1) {
 					AddStation(st, STR_305C_0, st->sign.width_1);
 				}
 			}
@@ -1185,9 +1253,9 @@
 			bottom += 2;
 			FOR_ALL_STATIONS(st) {
 				if (bottom > st->sign.top &&
-						top    < st->sign.top + 24 &&
+						top	 < st->sign.top + 24 &&
 						right  > st->sign.left &&
-						left   < st->sign.left + st->sign.width_1*2) {
+						left	 < st->sign.left + st->sign.width_1*2) {
 					AddStation(st, STR_305C_0, st->sign.width_1);
 				}
 			}
@@ -1239,6 +1307,26 @@
 	bottom = top + dpi->height;
 
 	switch (dpi->zoom) {
+		case ZOOM_LVL_IN_4X:
+			FOR_ALL_SIGNS(si) {
+				if (bottom > si->sign.top &&
+						top    < si->sign.top + 12 &&
+						right  > si->sign.left &&
+						left   < si->sign.left + si->sign.width_1) {
+					AddSign(si, STR_2806, si->sign.width_1);
+				}
+			}
+			break;
+		case ZOOM_LVL_IN_2X:
+			FOR_ALL_SIGNS(si) {
+				if (bottom > si->sign.top &&
+						top    < si->sign.top + 12 &&
+						right  > si->sign.left &&
+						left   < si->sign.left + si->sign.width_1) {
+					AddSign(si, STR_2806, si->sign.width_1);
+				}
+			}
+			break;
 		case ZOOM_LVL_NORMAL:
 			FOR_ALL_SIGNS(si) {
 				if (bottom > si->sign.top &&
@@ -1309,6 +1397,26 @@
 	bottom = top + dpi->height;
 
 	switch (dpi->zoom) {
+		case ZOOM_LVL_IN_4X:
+			FOR_ALL_WAYPOINTS(wp) {
+				if (bottom > wp->sign.top &&
+						top    < wp->sign.top + 12 &&
+						right  > wp->sign.left &&
+						left   < wp->sign.left + wp->sign.width_1) {
+					AddWaypoint(wp, STR_WAYPOINT_VIEWPORT, wp->sign.width_1);
+				}
+			}
+			break;
+		case ZOOM_LVL_IN_2X:
+			FOR_ALL_WAYPOINTS(wp) {
+				if (bottom > wp->sign.top &&
+						top    < wp->sign.top + 12 &&
+						right  > wp->sign.left &&
+						left   < wp->sign.left + wp->sign.width_1) {
+					AddWaypoint(wp, STR_WAYPOINT_VIEWPORT, wp->sign.width_1);
+				}
+			}
+			break;
 		case ZOOM_LVL_NORMAL:
 			FOR_ALL_WAYPOINTS(wp) {
 				if (bottom > wp->sign.top &&
@@ -1376,7 +1484,15 @@
 {
 	do {
 		Point pt = RemapCoords(ts->x, ts->y, ts->z);
-		DrawSprite(ts->image, ts->pal, pt.x, pt.y, ts->sub);
+		int left = UnScaleByZoom(pt.x,_cur_vd->vp->zoom);
+		int top =  UnScaleByZoom(pt.y,_cur_vd->vp->zoom);
+
+
+		left -= _cur_vd->vp->virtual_left;
+		top  -= _cur_vd->vp->virtual_top;
+
+		DrawSprite(ts->image, ts->pal, left, top, ts->sub);
+
 		ts = ts->next;
 	} while (ts != NULL);
 }
@@ -1443,14 +1559,18 @@
 
 static void ViewportDrawParentSprites(ParentSpriteToDraw *psd[])
 {
+	int  x,y, left, top;
 	for (; *psd != NULL; psd++) {
 		const ParentSpriteToDraw* ps = *psd;
 		const ChildScreenSpriteToDraw* cs;
+		x = UnScaleByZoom(ps->x, _cur_dpi->zoom) - _cur_vd->vp->virtual_left;
+		y = UnScaleByZoom(ps->y, _cur_dpi->zoom) - _cur_vd->vp->virtual_top;
+		left = UnScaleByZoom(ps->left, _cur_dpi->zoom) - _cur_vd->vp->virtual_left;
+		top = UnScaleByZoom(ps->top, _cur_dpi->zoom) - _cur_vd->vp->virtual_top;
+		if (ps->image != SPR_EMPTY_BOUNDING_BOX) DrawSprite(ps->image, ps->pal, x, y, &ps->sub);
 
-		if (ps->image != SPR_EMPTY_BOUNDING_BOX) DrawSprite(ps->image, ps->pal, ps->x, ps->y, ps->sub);
-
 		for (cs = ps->child; cs != NULL; cs = cs->next) {
-			DrawSprite(cs->image, cs->pal, ps->left + cs->x, ps->top + cs->y, cs->sub);
+			DrawSprite(cs->image, cs->pal, left + cs->x, top + cs->y, cs->sub);
 		}
 	}
 }
@@ -1461,13 +1581,24 @@
  */
 static void ViewportDrawBoundingBoxes(ParentSpriteToDraw *psd[])
 {
+	ZoomLevel zoom = _cur_dpi->zoom;
+	
 	for (; *psd != NULL; psd++) {
 		const ParentSpriteToDraw* ps = *psd;
-		Point pt1 = RemapCoords(ps->xmax + 1, ps->ymax + 1, ps->zmax + 1); // top front corner
-		Point pt2 = RemapCoords(ps->xmin    , ps->ymax + 1, ps->zmax + 1); // top left corner
-		Point pt3 = RemapCoords(ps->xmax + 1, ps->ymin    , ps->zmax + 1); // top right corner
-		Point pt4 = RemapCoords(ps->xmax + 1, ps->ymax + 1, ps->zmin    ); // bottom front corner
+		Point pt1 = RemapCoords(ps->xmax , ps->ymax, ps->zmax); // top front corner
+		Point pt2 = RemapCoords(ps->xmin , ps->ymax, ps->zmax); // top left corner
+		Point pt3 = RemapCoords(ps->xmax , ps->ymin, ps->zmax); // top right corner
+		Point pt4 = RemapCoords(ps->xmax , ps->ymax, ps->zmin); // bottom front corner
 
+		pt1.x =  UnScaleByZoom(pt1.x, zoom) -  _cur_vd->vp->virtual_left;
+		pt1.y =  UnScaleByZoom(pt1.y, zoom) -  _cur_vd->vp->virtual_top;
+		pt2.x =  UnScaleByZoom(pt2.x, zoom) -  _cur_vd->vp->virtual_left;
+		pt2.y =  UnScaleByZoom(pt2.y, zoom) -  _cur_vd->vp->virtual_top;
+		pt3.x =  UnScaleByZoom(pt3.x, zoom) -  _cur_vd->vp->virtual_left;
+		pt3.y =  UnScaleByZoom(pt3.y, zoom) -  _cur_vd->vp->virtual_top;
+		pt4.x =  UnScaleByZoom(pt4.x, zoom) -  _cur_vd->vp->virtual_left;
+		pt4.y =  UnScaleByZoom(pt4.y, zoom) -  _cur_vd->vp->virtual_top;
+
 		DrawBox(        pt1.x,         pt1.y,
 		        pt2.x - pt1.x, pt2.y - pt1.y,
 		        pt3.x - pt1.x, pt3.y - pt1.y,
@@ -1486,11 +1617,6 @@
 	zoom = dp.zoom;
 	dp.zoom = ZOOM_LVL_NORMAL;
 
-	dp.left   = UnScaleByZoom(dp.left,   zoom);
-	dp.top    = UnScaleByZoom(dp.top,    zoom);
-	dp.width  = UnScaleByZoom(dp.width,  zoom);
-	dp.height = UnScaleByZoom(dp.height, zoom);
-
 	do {
 		uint16 colour;
 
@@ -1500,9 +1626,9 @@
 				ss = ss->next;
 				continue;
 			}
+			int x = UnScaleByZoom(ss->x, zoom) - 1 - _cur_vd->vp->virtual_left;
+			int y = UnScaleByZoom(ss->y, zoom) - 1 - _cur_vd->vp->virtual_top;
 
-			int x = UnScaleByZoom(ss->x, zoom) - 1;
-			int y = UnScaleByZoom(ss->y, zoom) - 1;
 			int bottom = y + 11;
 			int w = ss->width;
 
@@ -1535,7 +1661,7 @@
 			colour = TC_BLACK;
 		}
 		DrawString(
-			UnScaleByZoom(ss->x, zoom), UnScaleByZoom(ss->y, zoom) - (ss->width & 0x8000 ? 2 : 0),
+			UnScaleByZoom(ss->x, zoom) - _cur_vd->vp->virtual_left, UnScaleByZoom(ss->y, zoom) - (ss->width & 0x8000 ? 2 : 0)- _cur_vd->vp->virtual_top,
 			ss->string, colour
 		);
 
@@ -1546,32 +1672,34 @@
 void ViewportDoDraw(const ViewPort *vp, int left, int top, int right, int bottom)
 {
 	ViewportDrawer vd;
-	int mask;
 	int x;
 	int y;
 	DrawPixelInfo *old_dpi;
+	DrawPixelInfo tmp_dpi;
 
 	SmallStackSafeStackAlloc<byte, VIEWPORT_DRAW_MEM> mem;
 	SmallStackSafeStackAlloc<ParentSpriteToDraw*, PARENT_LIST_SIZE> parent_list;
+	left = left - vp->left;
+	top  = top - vp->top;
+	right= right - vp->left;
+	bottom = bottom - vp->top;
 
 	_cur_vd = &vd;
 
 	old_dpi = _cur_dpi;
 	_cur_dpi = &vd.dpi;
 
+	vd.vp = vp;
 	vd.dpi.zoom = vp->zoom;
-	mask = ScaleByZoom(-1, vp->zoom);
-
 	vd.combine_sprites = 0;
-
-	vd.dpi.width = (right - left) & mask;
-	vd.dpi.height = (bottom - top) & mask;
-	vd.dpi.left = left & mask;
-	vd.dpi.top = top & mask;
+	vd.dpi.width = right - left;
+	vd.dpi.height = bottom - top;
+	vd.dpi.left = left;
+	vd.dpi.top = top;
 	vd.dpi.pitch = old_dpi->pitch;
 
-	x = UnScaleByZoom(vd.dpi.left - (vp->virtual_left & mask), vp->zoom) + vp->left;
-	y = UnScaleByZoom(vd.dpi.top - (vp->virtual_top & mask), vp->zoom) + vp->top;
+	x = left + vp->left;
+	y = top  + vp->top;
 
 	vd.dpi.dst_ptr = BlitterFactoryBase::GetCurrentBlitter()->MoveTo(old_dpi->dst_ptr, x - old_dpi->left, y - old_dpi->top);
 
@@ -1585,11 +1713,17 @@
 	vd.first_tile = NULL;
 
 	ViewportAddLandscape();
-	ViewportAddVehicles(&vd.dpi);
-	DrawTextEffects(&vd.dpi);
+	tmp_dpi = vd.dpi;
+	tmp_dpi.left = ScaleByZoom(vd.vp->virtual_left, vd.vp->zoom);
+	tmp_dpi.top = ScaleByZoom(vd.vp->virtual_top, vd.vp->zoom);
+	tmp_dpi.width = ScaleByZoom(vd.vp->width, vd.vp->zoom);
+	tmp_dpi.height = ScaleByZoom(vd.vp->height, vd.vp->zoom);
 
-	ViewportAddTownNames(&vd.dpi);
-	ViewportAddStationNames(&vd.dpi);
+	ViewportAddVehicles(&tmp_dpi);
+	DrawTextEffects(&tmp_dpi);
+
+	ViewportAddTownNames(&tmp_dpi);
+	ViewportAddStationNames(&tmp_dpi);
 	ViewportAddSigns(&vd.dpi);
 	ViewportAddWaypoints(&vd.dpi);
 
@@ -1616,7 +1750,8 @@
  * If we do, the sprite memory will overflow. */
 static void ViewportDrawChk(const ViewPort *vp, int left, int top, int right, int bottom)
 {
-	if (ScaleByZoom(bottom - top, vp->zoom) * ScaleByZoom(right - left, vp->zoom) > 180000) {
+	if (ScaleByZoom(bottom - top, vp->zoom) * ScaleByZoom(right - left, vp->zoom)
+	> 50000) {
 		if ((bottom - top) > (right - left)) {
 			int t = (top + bottom) >> 1;
 			ViewportDrawChk(vp, left, top, right, t);
@@ -1627,12 +1762,7 @@
 			ViewportDrawChk(vp, t, top, right, bottom);
 		}
 	} else {
-		ViewportDoDraw(vp,
-			ScaleByZoom(left - vp->left, vp->zoom) + vp->virtual_left,
-			ScaleByZoom(top - vp->top, vp->zoom) + vp->virtual_top,
-			ScaleByZoom(right - vp->left, vp->zoom) + vp->virtual_left,
-			ScaleByZoom(bottom - vp->top, vp->zoom) + vp->virtual_top
-		);
+		ViewportDoDraw(vp, left, top,	right, bottom);
 	}
 }
 
@@ -1734,26 +1864,32 @@
  */
 static void MarkViewportDirty(const ViewPort *vp, int left, int top, int right, int bottom)
 {
-	right -= vp->virtual_left;
-	if (right <= 0) return;
+	int vt, vl, w, h;
 
-	bottom -= vp->virtual_top;
-	if (bottom <= 0) return;
 
-	left = max(0, left - vp->virtual_left);
+	left = UnScaleByZoom(left, vp->zoom);
+	top  = UnScaleByZoom(top, vp->zoom);
+	right = UnScaleByZoom(right, vp->zoom);
+	bottom = UnScaleByZoom(bottom, vp->zoom);
 
-	if (left >= vp->virtual_width) return;
+	vl = vp->virtual_left;
+	vt = vp->virtual_top;
+	w = vp->width;
+	h = vp->height;
 
-	top = max(0, top - vp->virtual_top);
+	left = max(0, left - vl);
+	if (left >= w) return;
 
-	if (top >= vp->virtual_height) return;
+	top = max(0, top - vt);
+	if (top >= h ) return;
 
-	SetDirtyBlocks(
-		UnScaleByZoom(left, vp->zoom) + vp->left,
-		UnScaleByZoom(top, vp->zoom) + vp->top,
-		UnScaleByZoom(right, vp->zoom) + vp->left,
-		UnScaleByZoom(bottom, vp->zoom) + vp->top
-	);
+	right -= vl;
+	if (right <= 0) return;
+
+	bottom -= vt;
+	if (bottom <= 0) return;
+	
+	SetDirtyBlocks(left + vp->left, top + vp->top, right + vp->left, bottom + vp->top);
 }
 
 void MarkAllViewportsDirty(int left, int top, int right, int bottom)
@@ -1851,6 +1987,32 @@
 	if (!HasBit(_display_opt, DO_SHOW_TOWN_NAMES)) return false;
 
 	switch (vp->zoom) {
+		case ZOOM_LVL_IN_4X:
+			x = x - vp->left + vp->virtual_left;
+			y = y - vp->top  + vp->virtual_top;
+			FOR_ALL_TOWNS(t) {
+				if (y >= t->sign.top &&
+						y < t->sign.top + 12 &&
+						x >= t->sign.left &&
+						x < t->sign.left + t->sign.width_1) {
+					ShowTownViewWindow(t->index);
+					return true;
+				}
+			}
+			break;
+		case ZOOM_LVL_IN_2X:
+			x = x - vp->left + vp->virtual_left;
+			y = y - vp->top  + vp->virtual_top;
+			FOR_ALL_TOWNS(t) {
+				if (y >= t->sign.top &&
+						y < t->sign.top + 12 &&
+						x >= t->sign.left &&
+						x < t->sign.left + t->sign.width_1) {
+					ShowTownViewWindow(t->index);
+					return true;
+				}
+			}
+			break;
 		case ZOOM_LVL_NORMAL:
 			x = x - vp->left + vp->virtual_left;
 			y = y - vp->top  + vp->virtual_top;
@@ -1909,6 +2071,32 @@
 	if (!HasBit(_display_opt, DO_SHOW_STATION_NAMES)) return false;
 
 	switch (vp->zoom) {
+		case ZOOM_LVL_IN_4X:
+			x = x - vp->left + vp->virtual_left;
+			y = y - vp->top  + vp->virtual_top;
+			FOR_ALL_STATIONS(st) {
+				if (y >= st->sign.top &&
+						y < st->sign.top + 12 &&
+						x >= st->sign.left &&
+						x < st->sign.left + st->sign.width_1) {
+					ShowStationViewWindow(st->index);
+					return true;
+				}
+			}
+			break;
+		case ZOOM_LVL_IN_2X:
+			x = x - vp->left + vp->virtual_left;
+			y = y - vp->top  + vp->virtual_top;
+			FOR_ALL_STATIONS(st) {
+				if (y >= st->sign.top &&
+						y < st->sign.top + 12 &&
+						x >= st->sign.left &&
+						x < st->sign.left + st->sign.width_1) {
+					ShowStationViewWindow(st->index);
+					return true;
+				}
+			}
+			break;
 		case ZOOM_LVL_NORMAL:
 			x = x - vp->left + vp->virtual_left;
 			y = y - vp->top  + vp->virtual_top;
@@ -1968,6 +2156,32 @@
 	if (!HasBit(_display_opt, DO_SHOW_SIGNS) || IsInvisibilitySet(TO_SIGNS) || _current_player == PLAYER_SPECTATOR) return false;
 
 	switch (vp->zoom) {
+		case ZOOM_LVL_IN_4X:
+			x = x - vp->left + vp->virtual_left;
+			y = y - vp->top  + vp->virtual_top;
+			FOR_ALL_SIGNS(si) {
+				if (y >= si->sign.top &&
+						y <  si->sign.top + 12 &&
+						x >= si->sign.left &&
+						x <  si->sign.left + si->sign.width_1) {
+					ShowRenameSignWindow(si);
+					return true;
+				}
+			}
+			break;
+		case ZOOM_LVL_IN_2X:
+			x = x - vp->left + vp->virtual_left;
+			y = y - vp->top  + vp->virtual_top;
+			FOR_ALL_SIGNS(si) {
+				if (y >= si->sign.top &&
+						y <  si->sign.top + 12 &&
+						x >= si->sign.left &&
+						x <  si->sign.left + si->sign.width_1) {
+					ShowRenameSignWindow(si);
+					return true;
+				}
+			}
+			break;
 		case ZOOM_LVL_NORMAL:
 			x = x - vp->left + vp->virtual_left;
 			y = y - vp->top  + vp->virtual_top;
@@ -2026,6 +2240,32 @@
 	if (!HasBit(_display_opt, DO_WAYPOINTS)) return false;
 
 	switch (vp->zoom) {
+		case ZOOM_LVL_IN_4X:
+			x = x - vp->left + vp->virtual_left;
+			y = y - vp->top  + vp->virtual_top;
+			FOR_ALL_WAYPOINTS(wp) {
+				if (y >= wp->sign.top &&
+						y < wp->sign.top + 12 &&
+						x >= wp->sign.left &&
+						x < wp->sign.left + wp->sign.width_1) {
+					ShowRenameWaypointWindow(wp);
+					return true;
+				}
+			}
+			break;
+		case ZOOM_LVL_IN_2X:
+			x = x - vp->left + vp->virtual_left;
+			y = y - vp->top  + vp->virtual_top;
+			FOR_ALL_WAYPOINTS(wp) {
+				if (y >= wp->sign.top &&
+						y < wp->sign.top + 12 &&
+						x >= wp->sign.left &&
+						x < wp->sign.left + wp->sign.width_1) {
+					ShowRenameWaypointWindow(wp);
+					return true;
+				}
+			}
+			break;
 		case ZOOM_LVL_NORMAL:
 			x = x - vp->left + vp->virtual_left;
 			y = y - vp->top  + vp->virtual_top;
Index: src/blitter/32bpp_optimized.cpp
===================================================================
--- src/blitter/32bpp_optimized.cpp	(revision 12652)
+++ src/blitter/32bpp_optimized.cpp	(working copy)
@@ -1,6 +1,7 @@
 /* $Id$ */
 
 #include "../stdafx.h"
+#include "../core/alloc_func.hpp"
 #include "../zoom_func.h"
 #include "../gfx_func.h"
 #include "../debug.h"
@@ -14,53 +15,164 @@
 	uint32 *dst, *dst_line;
 
 	/* Find where to start reading in the source sprite */
-	src_line = (const SpriteLoader::CommonPixel *)bp->sprite + (bp->skip_top * bp->sprite_width + bp->skip_left) * ScaleByZoom(1, zoom);
+
+	src_line = (const SpriteLoader::CommonPixel *)bp->sprite + (bp->skip_top *  bp->sprite_width + bp->skip_left);
 	dst_line = (uint32 *)bp->dst + bp->top * bp->pitch + bp->left;
+	dst = dst_line;
+	src = src_line;
+	switch (mode) {
+		case BM_COLOUR_REMAP:
+			for (int y = 0; y < bp->height; y++) {
+				dst = dst_line;
+				dst_line += bp->pitch;
+				src = src_line;
+				src_line += bp->sprite_width ;
 
-	for (int y = 0; y < bp->height; y++) {
-		dst = dst_line;
-		dst_line += bp->pitch;
+				for (int x = 0; x < bp->width; x++) {
+					if (src->a == 0) {
+						/* src->r is 'misused' here to indicate how much more pixels are following with an alpha of 0 */
 
-		src = src_line;
-		src_line += bp->sprite_width * ScaleByZoom(1, zoom);
+						int skip = src->r;
 
-		for (int x = 0; x < bp->width; x++) {
-			if (src->a == 0) {
-				/* src->r is 'misused' here to indicate how much more pixels are following with an alpha of 0 */
-				int skip = UnScaleByZoom(src->r, zoom);
-
-				dst += skip;
-				x   += skip - 1;
-				src += ScaleByZoom(1, zoom) * skip;
-				continue;
+						dst += skip;
+						x	 += skip - 1;
+						src += skip;
+						continue;
+					}
+					/* In case the m-channel is zero, do not remap this pixel in any way */
+					if (src->m == 0) {
+						*dst = ComposeColourRGBA(src->r, src->g, src->b, src->a, *dst);
+					} else {
+						if (bp->remap[src->m] != 0) {
+							*dst = ComposeColourRGBA(src->r, src->g, src->b, src->a, *dst);
+							*dst = ComposeColourBlend(this->LookupColourInPalette(bp->remap[src->m]), *dst);
+						}
+					}
+					dst++;
+					src++;
+				}
 			}
+			break;
+		case BM_COLOUR_OPAQUE:
+			for (int y = 0; y < bp->height; y++) {
+				dst = dst_line;
+				dst_line += bp->pitch;
 
-			switch (mode) {
-				case BM_COLOUR_REMAP:
-					/* In case the m-channel is zero, do not remap this pixel in any way */
+				src = src_line;
+				src_line += bp->sprite_width ;
+
+				for (int x = 0; x < bp->width; x++) {
+					if (src->a == 0) {
+						/* src->r is 'misused' here to indicate how much more pixels are following with an alpha of 0 */
+
+						int skip = src->r;
+
+						dst += skip;
+						x	 += skip - 1;
+						src += skip;
+						continue;
+					}
+			  		/* In case the m-channel is zero, do not remap this pixel in any way */
 					if (src->m == 0) {
 						*dst = ComposeColourRGBA(src->r, src->g, src->b, src->a, *dst);
 					} else {
 						if (bp->remap[src->m] != 0) *dst = ComposeColourPA(this->LookupColourInPalette(bp->remap[src->m]), src->a, *dst);
 					}
-					break;
+					dst++;
+					src++;
+				}
+			}
+			break;
+		case BM_TRANSPARENT:
+			for (int y = 0; y < bp->height; y++) {
+				dst = dst_line;
+				dst_line += bp->pitch;
 
-				case BM_TRANSPARENT:
-					/* TODO -- We make an assumption here that the remap in fact is transparency, not some color.
-					 *  This is never a problem with the code we produce, but newgrfs can make it fail... or at least:
-					 *  we produce a result the newgrf maker didn't expect ;) */
+				src = src_line;
+				src_line += bp->sprite_width ;
 
-					/* Make the current color a bit more black, so it looks like this image is transparent */
-					*dst = MakeTransparent(*dst, 192);
-					break;
+				for (int x = 0; x < bp->width; x++) {
+					if (src->a == 0) {
+					/* src->r is 'misused' here to indicate how much more pixels are following with an alpha of 0 */
 
-				default:
-					*dst = ComposeColourRGBA(src->r, src->g, src->b, src->a, *dst);
-					break;
+						int skip = src->r;
+
+						dst += skip;
+						x	 += skip - 1;
+						src += skip;
+						continue;
+					}
+					/* GeekToo: for 32bpp remap of colours and transparency are not
+						mutual exclusive. For now, check the remap ptr to check for
+						remapping, in the future a cleaner solution will be to create
+						an extra blitter mode
+					*/
+
+  					if (src->m == 0) {
+						*dst = ComposeColourRGBA(src->r, src->g, src->b, src->a/2, *dst);
+					} else {
+						if (bp->remap) {
+							if (bp->remap[src->m] != 0) *dst =
+							  ComposeColourPA(this->LookupColourInPalette(bp->remap[src->m]), src->a/2, *dst);
+						} else
+	  						*dst = ComposeColourRGBA(src->r, src->g, src->b, src->a/2, *dst);
+					}
+
+					dst++;
+					src++;
+				}
 			}
-			dst++;
-			src += ScaleByZoom(1, zoom);
-		}
+			break;
+		case BM_SHADOW:
+			for (int y = 0; y < bp->height; y++) {
+				dst = dst_line;
+				dst_line += bp->pitch;
+
+				src = src_line;
+				src_line += bp->sprite_width ;
+
+				for (int x = 0; x < bp->width; x++) {
+					if (src->a == 0) {
+						/* src->r is 'misused' here to indicate how much more pixels are following with an alpha of 0 */
+
+						int skip = src->r;
+
+						dst += skip;
+						x	 += skip - 1;
+						src += skip;
+						continue;
+					}
+					*dst = MakeTransparent(*dst, 150);
+
+					dst++;
+					src++;
+				}
+			}
+			break;
+		default:
+			for (int y = 0; y < bp->height; y++) {
+				dst = dst_line;
+				dst_line += bp->pitch;
+
+				src = src_line;
+				src_line += bp->sprite_width ;
+
+				for (int x = 0; x < bp->width; x++) {
+					if (src[x].a == 0) {
+					/* src->r is 'misused' here to indicate how much more pixels are following with an alpha of 0 */
+						int skip = src[x].r;
+						x	 += skip - 1;
+						continue;
+					}	
+					if (src[x].a == 255) {
+						dst[x] = ComposeColour(src[x].a, src[x].r, src[x].g, src[x].b);
+							continue;
+					}	
+					dst[x] = ComposeColourRGBA(src[x].r, src[x].g, src[x].b, src[x].a, dst[x]);
+				}
+
+			}
+			break;
 	}
 }
 
@@ -89,21 +201,236 @@
 				/* Save transparent block length in red channel; max value is 255 the red channel can contain */
 				if (trans < 255) trans++;
 				dst->r = trans;
-				dst->g = 0;
-				dst->b = 0;
-				dst->m = 0;
 			} else {
 				trans = 0;
-				if (dst->m != 0) {
-					/* Pre-convert the mapping channel to a RGB value */
-					uint color = this->LookupColourInPalette(dst->m);
-					dst->r = GB(color, 16, 8);
-					dst->g = GB(color, 8,  8);
-					dst->b = GB(color, 0,  8);
-				}
 			}
 			dst--;
 		}
 	}
 	return dest_sprite;
 }
+
+void Blitter_32bppOptimized::RescaleSpriteHalfSize(const SpriteLoader::Sprite *src_sprite,
+																			SpriteLoader::Sprite *dest_sprite,
+																			bool					  prevent_alpha_bleeding)
+{
+	SpriteLoader::CommonPixel *dst;
+	SpriteLoader::CommonPixel *src;
+	int width, height;
+	int x, y;
+	bool  extra_px_x	= false;
+	bool  extra_px_y	= false;
+	
+	SpriteLoader::CommonPixel clr;
+
+	width = (src_sprite->width + 1) / 2;
+	height = (src_sprite->height + 1) / 2;
+
+	/* src sprite width is odd, just copy last pixel iso taking average */
+	if (src_sprite->width & 1) {
+		extra_px_x = true;
+	}
+	/* src sprite height is odd, just copy last pixel iso taking average */
+	if (src_sprite->height & 1) {
+		extra_px_y = true;
+	}
+
+
+	dest_sprite->data = CallocT<SpriteLoader::CommonPixel>(height * width);
+	dst = (SpriteLoader::CommonPixel *)dest_sprite->data;
+	src = (SpriteLoader::CommonPixel *)src_sprite->data;
+	
+	dest_sprite->width = width ;
+	dest_sprite->height = height;
+
+	dest_sprite->x_offs = src_sprite->x_offs / 2;
+	dest_sprite->y_offs = src_sprite->y_offs / 2;
+
+	for (y = 0; y < height + (extra_px_y ? -1 : 0); y++) {
+		for (x = 0; x < width + (extra_px_x ? -1 : 0); x++) {
+				uint ma = 0;
+				uint a = 0;
+				uint r = 0;
+				uint g = 0;
+				uint b = 0;
+				uint i;
+				uint j;
+
+				for (i = 0; i < 2; i++) {
+					for (j = 0; j < 2; j++) {
+						uint ca;
+						uint cr;
+						uint cg;
+						uint cb;
+
+						clr = src[((2 * y + i ) * src_sprite->width) + (2 * x + j )];
+						ca = clr.a;
+						cr = clr.r;
+						cg = clr.g;
+						cb = clr.b;
+
+						a += ca;
+						r += ca * cr;
+						g += ca * cg;
+						b += ca * cb;
+						if (prevent_alpha_bleeding) {
+							if (ca > ma) ma = ca;
+						} else {
+							ma += ca;
+						}
+					}
+				}
+
+				if (a == 0) {
+  					dst[y * width + x].r = 0;
+  					dst[y * width + x].g = 0;
+  					dst[y * width + x].b = 0;
+  					dst[y * width + x].a = 0;
+  					dst[y * width + x].m = 0;
+				} else {
+					r /= a;
+					g /= a;
+					b /= a;
+					if (prevent_alpha_bleeding) {
+						a = ma;
+					} else {
+						a /= 4;
+					}
+  					dst[y * width + x].r = r;
+  					dst[y * width + x].g = g;
+  					dst[y * width + x].b = b;
+  					dst[y * width + x].a = a;
+  					dst[y * width + x].m = clr.m;
+				}
+		}
+		if (extra_px_x) {
+			clr = src[((2 * y ) * src_sprite->width) + (2 * x)];
+			dst[y * width + x] = clr;
+		}
+	}
+
+}
+
+void Blitter_32bppOptimized::RescaleSpriteDoubleSize(const SpriteLoader::Sprite *src_sprite,
+																			  SpriteLoader::Sprite *dest_sprite)
+{
+	int width, height;
+	SpriteLoader::CommonPixel *dst;
+	SpriteLoader::CommonPixel *src;
+	
+	width = src_sprite->width * 2;
+	height = src_sprite->height * 2;
+
+	dest_sprite->data = CallocT<SpriteLoader::CommonPixel>(height * width);
+	dst = (SpriteLoader::CommonPixel *)dest_sprite->data;
+	src = (SpriteLoader::CommonPixel *)src_sprite->data;
+
+	dest_sprite->width = width;
+	dest_sprite->height = height;
+	dest_sprite->x_offs = src_sprite->x_offs * 2;
+	dest_sprite->y_offs = src_sprite->y_offs * 2;
+
+	uint dst_y = 0;
+	uint src_y_idx = 0;
+	for (int y = 0; y < src_sprite->height - 1; y++) {
+	   int x;
+
+		uint dst_x = 0;
+		for (x = 0; x < src_sprite->width - 1; x++) {
+			dst[dst_y + dst_x] = src[src_y_idx + x];
+			dst_x++;
+			dst[dst_y + dst_x].r = (src[src_y_idx + x + 1].r + src[src_y_idx + x].r) / 2;
+			dst[dst_y + dst_x].g = (src[src_y_idx + x + 1].g + src[src_y_idx + x].g) / 2;
+			dst[dst_y + dst_x].b = (src[src_y_idx + x + 1].b + src[src_y_idx + x].b) / 2;
+			dst[dst_y + dst_x].a = (src[src_y_idx + x + 1].a + src[src_y_idx + x].a) / 2;
+			dst[dst_y + dst_x].m =  src[src_y_idx + x].m;
+			dst_x--;
+			dst_y += width;
+			dst[dst_y + dst_x].r = (src[src_y_idx + x].r + src[src_y_idx +	src_sprite->width + x].r) / 2;
+			dst[dst_y + dst_x].g = (src[src_y_idx + x].g + src[src_y_idx +	src_sprite->width + x].g) / 2;
+			dst[dst_y + dst_x].b = (src[src_y_idx + x].b + src[src_y_idx +	src_sprite->width + x].b) / 2;
+			dst[dst_y + dst_x].a = (src[src_y_idx + x].a + src[src_y_idx + src_sprite->width + x].a) / 2;
+			dst[dst_y + dst_x].m =  src[src_y_idx + x].m;
+			dst_x++;
+			dst[dst_y + dst_x].r = (src[src_y_idx + x].r + src[src_y_idx +	src_sprite->width + x].r +
+			                        src[src_y_idx + x + 1].r + src[src_y_idx + src_sprite->width + x + 1].r ) / 4;
+			dst[dst_y + dst_x].g = (src[src_y_idx + x].g + src[src_y_idx +	src_sprite->width + x].g +
+			                        src[src_y_idx + x + 1].g + src[src_y_idx + src_sprite->width + x + 1].g ) / 4;
+			dst[dst_y + dst_x].b = (src[src_y_idx + x].b + src[src_y_idx +	src_sprite->width + x].b +
+			                        src[src_y_idx + x + 1].b + src[src_y_idx + src_sprite->width + x + 1].b ) / 4;
+			dst[dst_y + dst_x].a = (src[src_y_idx + x].a + src[src_y_idx +	src_sprite->width + x].a +
+			                        src[src_y_idx + x + 1].a + src[src_y_idx + src_sprite->width + x + 1].a ) / 4;
+			dst[dst_y + dst_x].m =  src[src_y_idx + x].m;
+			dst_y -= width;
+			dst_x++;
+		}
+		
+		/* last pixels in row cannot be interpolated */
+		dst[dst_y + dst_x] = src[src_y_idx + x];
+		dst_x++;
+		dst[dst_y + dst_x] = src[src_y_idx + x];
+		dst_x--;
+		dst_y += width;
+		dst[dst_y + dst_x].r = (src[src_y_idx + x].r + src[src_y_idx +	src_sprite->width + x].r) / 2;
+		dst[dst_y + dst_x].g = (src[src_y_idx + x].g + src[src_y_idx +	src_sprite->width + x].g) / 2;
+		dst[dst_y + dst_x].b = (src[src_y_idx + x].b + src[src_y_idx +	src_sprite->width + x].b) / 2;
+		dst[dst_y + dst_x].a = (src[src_y_idx + x].a + src[src_y_idx + src_sprite->width + x].a) / 2;
+		dst[dst_y + dst_x].m =  src[src_y_idx + x].m;
+		dst_x++;
+		dst[dst_y + dst_x].r = (src[src_y_idx + x].r + src[src_y_idx +	src_sprite->width + x].r) / 2;
+		dst[dst_y + dst_x].g = (src[src_y_idx + x].g + src[src_y_idx +	src_sprite->width + x].g) / 2;
+		dst[dst_y + dst_x].b = (src[src_y_idx + x].b + src[src_y_idx +	src_sprite->width + x].b) / 2;
+		dst[dst_y + dst_x].a = (src[src_y_idx + x].a + src[src_y_idx + src_sprite->width + x].a) / 2;
+		dst[dst_y + dst_x].m =  src[src_y_idx + x].m;
+
+		dst_y += width;
+		src_y_idx += src_sprite->width;
+	}
+	/* last row can not be interpolated */
+	uint dst_x = 0;
+	for (int x = 0; x < src_sprite->width - 1; x++) {
+		dst[dst_y + dst_x] = src[src_y_idx + x];
+		dst_x++;
+		dst[dst_y + dst_x].r = (src[src_y_idx + x + 1].r + src[src_y_idx + x].r) / 2;
+		dst[dst_y + dst_x].g = (src[src_y_idx + x + 1].g + src[src_y_idx + x].g) / 2;
+		dst[dst_y + dst_x].b = (src[src_y_idx + x + 1].b + src[src_y_idx + x].b) / 2;
+		dst[dst_y + dst_x].a = (src[src_y_idx + x + 1].a + src[src_y_idx + x].a) / 2;
+		dst[dst_y + dst_x].m =  src[src_y_idx + x].m;
+		dst_x--;
+		dst_y += width;
+		dst[dst_y + dst_x] = src[src_y_idx + x];
+		dst_x++;
+		dst[dst_y + dst_x].r = (src[src_y_idx + x + 1].r + src[src_y_idx + x].r) / 2;
+		dst[dst_y + dst_x].g = (src[src_y_idx + x + 1].g + src[src_y_idx + x].g) / 2;
+		dst[dst_y + dst_x].b = (src[src_y_idx + x + 1].b + src[src_y_idx + x].b) / 2;
+		dst[dst_y + dst_x].a = (src[src_y_idx + x + 1].a + src[src_y_idx + x].a) / 2;
+		dst[dst_y + dst_x].m =  src[src_y_idx + x].m;
+		dst_y -= width;
+		dst_x++;
+	}
+}
+
+void Blitter_32bppOptimized::FillRGBFromPalette(SpriteLoader::Sprite *sprite)
+{
+	SpriteLoader::CommonPixel *spr = sprite->data;
+	
+	for (uint y = 0; y < sprite->height; y++) {
+		uint y_idx  = y * sprite->width; 
+		for (uint x = 0; x < sprite->width; x++) {
+			if (spr[y_idx + x].a == 0) {
+				spr[y_idx + x].r = 0;
+				spr[y_idx + x].g = 0;
+				spr[y_idx + x].b = 0;
+				spr[y_idx + x].m = 0;
+			} else {
+				if (spr[y_idx + x].m != 0) {
+					/* Pre-convert the mapping channel to a RGB value */
+					uint color = this->LookupColourInPalette(spr[y_idx + x].m);
+					spr[y_idx + x].r = GB(color, 16, 8);
+					spr[y_idx + x].g = GB(color, 8,  8);
+					spr[y_idx + x].b = GB(color, 0,  8);
+				}
+			}
+		}
+	}
+}
Index: src/blitter/base.hpp
===================================================================
--- src/blitter/base.hpp	(revision 12652)
+++ src/blitter/base.hpp	(working copy)
@@ -11,6 +11,8 @@
 	BM_NORMAL,
 	BM_COLOUR_REMAP,
 	BM_TRANSPARENT,
+   BM_COLOUR_OPAQUE,
+   BM_SHADOW
 };
 
 /**
Index: src/blitter/32bpp_optimized.hpp
===================================================================
--- src/blitter/32bpp_optimized.hpp	(revision 12652)
+++ src/blitter/32bpp_optimized.hpp	(working copy)
@@ -10,9 +10,14 @@
 
 class Blitter_32bppOptimized : public Blitter_32bppSimple {
 public:
-	/* virtual */ void Draw(Blitter::BlitterParams *bp, BlitterMode mode, ZoomLevel zoom);
-	/* virtual */ Sprite *Encode(SpriteLoader::Sprite *sprite, Blitter::AllocatorProc *allocator);
-
+	/* virtual */ 	void Draw(Blitter::BlitterParams *bp, BlitterMode mode, ZoomLevel zoom);
+	/* virtual */ 	Sprite *Encode(SpriteLoader::Sprite *sprite, Blitter::AllocatorProc *allocator);
+						void RescaleSpriteHalfSize(const SpriteLoader::Sprite *src_sprite, 
+																	SpriteLoader::Sprite *dest_sprite,
+																	bool						 prevent_alpha_bleeding);
+						void RescaleSpriteDoubleSize(const SpriteLoader::Sprite *src_sprite,
+																	  SpriteLoader::Sprite *dest_sprite);                                               
+						void FillRGBFromPalette(SpriteLoader::Sprite *sprite);
 	/* virtual */ const char *GetName() { return "32bpp-optimized"; }
 };
 
Index: src/blitter/32bpp_base.hpp
===================================================================
--- src/blitter/32bpp_base.hpp	(revision 12652)
+++ src/blitter/32bpp_base.hpp	(working copy)
@@ -7,6 +7,7 @@
 
 #include "base.hpp"
 #include "../core/bitmath_func.hpp"
+#include "../core/math_func.hpp"
 
 class Blitter_32bppBase : public Blitter {
 public:
@@ -59,6 +60,11 @@
 
 		/* The 256 is wrong, it should be 255, but 256 is much faster... */
 		return ComposeColour(0xFF,
+												((r - cr) * a ) / 256 + cr,
+												((g - cg) * a ) / 256 + cg,
+												((b - cb) * a ) / 256 + cb);
+
+		return ComposeColour(0xFF,
 												(r * a + cr * (256 - a)) / 256,
 												(g * a + cg * (256 - a)) / 256,
 												(b * a + cb * (256 - a)) / 256);
@@ -79,6 +85,11 @@
 		cr = GB(current, 16, 8);
 		cg = GB(current, 8,  8);
 		cb = GB(current, 0,  8);
+		/* The 256 is wrong, it should be 255, but 256 is much faster... */
+		return ComposeColour(0xFF,
+												((r - cr) * a ) / 256 + cr,
+												((g - cg) * a ) / 256 + cg,
+												((b - cb) * a ) / 256 + cb);
 
 		/* The 256 is wrong, it should be 255, but 256 is much faster... */
 		return ComposeColour(0xFF,
@@ -87,6 +98,75 @@
 												(b * a + cb * (256 - a)) / 256);
 	}
 
+/**
+	* Blend a colour based on Pixel value and the current pixel value.
+	*/
+	static inline uint ComposeColourBlend(uint colour, uint current)
+	{
+		uint r, g, b, cr, cg, cb;
+
+		if (colour == current) {
+			return colour;
+		}
+
+		r  = GB(colour,  16, 8);
+		g  = GB(colour,  8,  8);
+		b  = GB(colour,  0,  8);
+		
+		cr = GB(current, 16, 8);
+		cg = GB(current, 8,  8);
+		cb = GB(current, 0,  8);
+
+		if (cr < cg)
+			Swap(cr,cg);
+		if (cg < cb)
+			Swap(cg,cb);
+		if (cr < cg)
+			Swap(cr,cg);
+			
+		if (r>g) {
+			if(r>b) {
+				r = cr;
+				if(b>g){
+					b = cg;
+					g = cb;
+				}
+				else {
+					g = cg;
+					b = cb;
+				}
+			}
+			else {
+				b = cr;
+				r = cg;
+				g = cb;
+			}
+		}
+		else {
+			if(r>b) {
+				g = cr;
+				r = cg;
+				b = cb;
+			}
+			else {
+				if(b>g) {
+					b = cr;
+					g = cg;
+					r = cb;
+				}
+				else {
+					if ((r != g) && (r != b)){
+						g = cr;
+						b = cg;
+						r = cb;
+					}
+				}
+			}
+		}
+  		return ComposeColour(0xff,r,g,b);		
+	}
+
+
 	/**
 	* Make a pixel looks like it is transparent.
 	* @param colour the colour already on the screen.
@@ -95,7 +175,8 @@
 	*/
 	static inline uint MakeTransparent(uint colour, uint amount)
 	{
-		uint r, g, b;
+		uint r, g, b, a;
+ 		a = GB(colour, 24, 8);
 		r = GB(colour, 16, 8);
 		g = GB(colour, 8,  8);
 		b = GB(colour, 0,  8);
Index: src/blitter/32bpp_anim.cpp
===================================================================
--- src/blitter/32bpp_anim.cpp	(revision 12652)
+++ src/blitter/32bpp_anim.cpp	(working copy)
@@ -79,8 +79,10 @@
 					 *  we produce a result the newgrf maker didn't expect ;) */
 
 					/* Make the current color a bit more black, so it looks like this image is transparent */
-					*dst = MakeTransparent(*dst, 192);
-					*anim = bp->remap[*anim];
+//					*dst = MakeTransparent(*dst, 192);
+     				*dst = ComposeColourRGBA(src->r, src->g, src->b, src->a * 100/256, *dst);
+//					*anim = bp->remap[*anim];
+					*anim = src->m;
 					break;
 
 				default:
Index: src/gfx.cpp
===================================================================
--- src/gfx.cpp	(revision 12652)
+++ src/gfx.cpp	(working copy)
@@ -196,16 +196,16 @@
 
 	static const byte color = 255;
 
-	GfxDrawLineUnscaled(x, y, x + dx1, y + dy1, color);
-	GfxDrawLineUnscaled(x, y, x + dx2, y + dy2, color);
-	GfxDrawLineUnscaled(x, y, x + dx3, y + dy3, color);
+	GfxDrawLine(x, y, x + dx1, y + dy1, color);
+	GfxDrawLine(x, y, x + dx2, y + dy2, color);
+	GfxDrawLine(x, y, x + dx3, y + dy3, color);
 
-	GfxDrawLineUnscaled(x + dx1, y + dy1, x + dx1 + dx2, y + dy1 + dy2, color);
-	GfxDrawLineUnscaled(x + dx1, y + dy1, x + dx1 + dx3, y + dy1 + dy3, color);
-	GfxDrawLineUnscaled(x + dx2, y + dy2, x + dx2 + dx1, y + dy2 + dy1, color);
-	GfxDrawLineUnscaled(x + dx2, y + dy2, x + dx2 + dx3, y + dy2 + dy3, color);
-	GfxDrawLineUnscaled(x + dx3, y + dy3, x + dx3 + dx1, y + dy3 + dy1, color);
-	GfxDrawLineUnscaled(x + dx3, y + dy3, x + dx3 + dx2, y + dy3 + dy2, color);
+	GfxDrawLine(x + dx1, y + dy1, x + dx1 + dx2, y + dy1 + dy2, color);
+	GfxDrawLine(x + dx1, y + dy1, x + dx1 + dx3, y + dy1 + dy3, color);
+	GfxDrawLine(x + dx2, y + dy2, x + dx2 + dx1, y + dy2 + dy1, color);
+	GfxDrawLine(x + dx2, y + dy2, x + dx2 + dx3, y + dy2 + dy3, color);
+	GfxDrawLine(x + dx3, y + dy3, x + dx3 + dx1, y + dy3 + dy1, color);
+	GfxDrawLine(x + dx3, y + dy3, x + dx3 + dx2, y + dy3 + dy2, color);
 }
 
 
@@ -633,7 +633,7 @@
 		if (IsPrintable(c)) {
 			if (x >= dpi->left + dpi->width) goto skip_char;
 			if (x + 26 >= dpi->left) {
-				GfxMainBlitter(GetGlyph(size, c), x, y, BM_COLOUR_REMAP);
+				GfxMainBlitter(GetGlyph(size, c), x, y, BM_COLOUR_OPAQUE);
 			}
 			x += GetCharacterWidth(size, c);
 		} else if (c == '\n') { // newline = {}
@@ -673,12 +673,21 @@
 void DrawSprite(SpriteID img, SpriteID pal, int x, int y, const SubSprite *sub)
 {
 	if (HasBit(img, PALETTE_MODIFIER_TRANSPARENT)) {
-		_color_remap_ptr = GetNonSprite(GB(pal, 0, PALETTE_WIDTH)) + 1;
+      if (pal != PAL_NONE) {
+	   	_color_remap_ptr = GetNonSprite(GB(pal, 0, PALETTE_WIDTH)) + 1;
+		}
+      else
+      {
+         _color_remap_ptr = NULL;
+      }
 		GfxMainBlitter(GetSprite(GB(img, 0, SPRITE_WIDTH)), x, y, BM_TRANSPARENT, sub);
+   } else if (HasBit(img, PALETTE_MODIFIER_SHADOW)){
+   	GfxMainBlitter(GetSprite(GB(img, 0, SPRITE_WIDTH)), x, y, BM_SHADOW, sub);
 	} else if (pal != PAL_NONE) {
 		_color_remap_ptr = GetNonSprite(GB(pal, 0, PALETTE_WIDTH)) + 1;
 		GfxMainBlitter(GetSprite(GB(img, 0, SPRITE_WIDTH)), x, y, BM_COLOUR_REMAP, sub);
-	} else {
+	}
+   else {
 		GfxMainBlitter(GetSprite(GB(img, 0, SPRITE_WIDTH)), x, y, BM_NORMAL, sub);
 	}
 }
@@ -689,11 +698,20 @@
 	Blitter::BlitterParams bp;
 
 	/* Amount of pixels to clip from the source sprite */
-	int clip_left   = (sub != NULL ? max(0,                   -sprite->x_offs + sub->left       ) : 0);
-	int clip_top    = (sub != NULL ? max(0,                   -sprite->y_offs + sub->top        ) : 0);
-	int clip_right  = (sub != NULL ? max(0, sprite->width  - (-sprite->x_offs + sub->right  + 1)) : 0);
-	int clip_bottom = (sub != NULL ? max(0, sprite->height - (-sprite->y_offs + sub->bottom + 1)) : 0);
 
+	int clip_left   = 0;
+	int clip_top    = 0;
+	int clip_right  = 0;
+	int clip_bottom = 0;
+
+	if ( sub && sub->right != 0x7FFF)
+	{
+		clip_left   = max(0,                   -sprite->x_offs + sub->left       );
+		clip_top    = max(0,                   -sprite->y_offs + sub->top        );
+		clip_right  = max(0, sprite->width  - (-sprite->x_offs + sub->right  + 1));
+		clip_bottom = max(0, sprite->height - (-sprite->y_offs + sub->bottom + 1));
+	}
+
 	if (clip_left + clip_right >= sprite->width) return;
 	if (clip_top + clip_bottom >= sprite->height) return;
 
@@ -705,15 +723,17 @@
 	bp.sprite = sprite->data;
 	bp.sprite_width = sprite->width;
 	bp.sprite_height = sprite->height;
-	bp.width = UnScaleByZoom(sprite->width - clip_left - clip_right, dpi->zoom);
-	bp.height = UnScaleByZoom(sprite->height - clip_top - clip_bottom, dpi->zoom);
+
+
+	bp.width = (sprite->width - clip_left - clip_right) ;
+	bp.height = (sprite->height - clip_top - clip_bottom) ;
 	bp.top = 0;
 	bp.left = 0;
-	bp.skip_left = UnScaleByZoom(clip_left, dpi->zoom);
-	bp.skip_top = UnScaleByZoom(clip_top, dpi->zoom);
+	bp.skip_left = clip_left ;
+	bp.skip_top = clip_top ;
 
-	x += ScaleByZoom(bp.skip_left, dpi->zoom);
-	y += ScaleByZoom(bp.skip_top, dpi->zoom);
+	x += bp.skip_left;
+	y += bp.skip_top;
 
 	bp.dst = dpi->dst_ptr;
 	bp.pitch = dpi->pitch;
@@ -727,37 +747,40 @@
 
 	y -= dpi->top;
 	/* Check for top overflow */
+
 	if (y < 0) {
-		bp.height -= -UnScaleByZoom(y, dpi->zoom);
+		bp.height -= -y;
 		if (bp.height <= 0) return;
-		bp.skip_top += -UnScaleByZoom(y, dpi->zoom);
+		bp.skip_top += -y;
 		y = 0;
 	} else {
-		bp.top = UnScaleByZoom(y, dpi->zoom);
+		bp.top = y;
 	}
 
 	/* Check for bottom overflow */
-	y += ScaleByZoom(bp.height, dpi->zoom) - dpi->height;
+
+	y += bp.height - dpi->height;
+
 	if (y > 0) {
-		bp.height -= UnScaleByZoom(y, dpi->zoom);
+		bp.height -= y; 
 		if (bp.height <= 0) return;
 	}
 
 	x -= dpi->left;
 	/* Check for left overflow */
 	if (x < 0) {
-		bp.width -= -UnScaleByZoom(x, dpi->zoom);
+		bp.width -= -x;
 		if (bp.width <= 0) return;
-		bp.skip_left += -UnScaleByZoom(x, dpi->zoom);
+		bp.skip_left += -x ;
 		x = 0;
 	} else {
-		bp.left = UnScaleByZoom(x, dpi->zoom);
+		bp.left = x;
 	}
 
 	/* Check for right overflow */
-	x += ScaleByZoom(bp.width, dpi->zoom) - dpi->width;
+	x += bp.width - dpi->width;
 	if (x > 0) {
-		bp.width -= UnScaleByZoom(x, dpi->zoom);
+		bp.width -= x;
 		if (bp.width <= 0) return;
 	}
 
@@ -1134,7 +1157,10 @@
 	byte *b;
 	int width;
 	int height;
-
+   left -=7;
+   right += 7;
+   top -= 7;
+   bottom += 7;
 	if (left < 0) left = 0;
 	if (top < 0) top = 0;
 	if (right > _screen.width) right = _screen.width;
Index: src/vehicle_base.h
===================================================================
--- src/vehicle_base.h	(revision 12652)
+++ src/vehicle_base.h	(working copy)
@@ -67,6 +67,8 @@
 	VS_SHADOW          = 0x20,
 	VS_AIRCRAFT_BROKEN = 0x40,
 	VS_CRASHED         = 0x80,
+	VS_CLIP_RIGHT      = 0x100,
+	VS_CLIP_LEFT       = 0x200,
 };
 
 enum VehicleFlags {
@@ -245,7 +247,7 @@
 	byte progress;
 	uint32 motion_counter;
 
-	byte vehstatus;          // Status
+	uint16 vehstatus;          // Status
 	StationID last_station_visited;
 
 	CargoID cargo_type;      // type of cargo this vehicle is carrying
Index: src/player_gui.cpp
===================================================================
--- src/player_gui.cpp	(revision 12652)
+++ src/player_gui.cpp	(working copy)
@@ -29,7 +29,7 @@
 #include "string_func.h"
 #include "settings_type.h"
 #include "widgets/dropdown_func.h"
-
+#include "zoom_type.h"
 #include "table/sprites.h"
 #include "table/strings.h"
 
@@ -571,6 +571,7 @@
 		}
 		DrawSprite(GetPlayerFaceSprite(pf, pfv, ge), (pfv == PFV_EYEBROWS) ? pal : PAL_NONE, x, y);
 	}
+
 }
 
 /**
@@ -632,67 +633,67 @@
 /** Widget description for the normal/simple player face selection dialog */
 static const Widget _select_player_face_widgets[] = {
 {   WWT_CLOSEBOX,   RESIZE_NONE,    14,     0,    10,     0,    13, STR_00C5,                STR_018B_CLOSE_WINDOW},              // PFW_WIDGET_CLOSEBOX
-{    WWT_CAPTION,   RESIZE_NONE,    14,    11,   174,     0,    13, STR_7043_FACE_SELECTION, STR_018C_WINDOW_TITLE_DRAG_THIS},    // PFW_WIDGET_CAPTION
-{     WWT_IMGBTN,   RESIZE_NONE,    14,   175,   189,     0,    13, SPR_LARGE_SMALL_WINDOW,  STR_FACE_ADVANCED_TIP},              // PFW_WIDGET_TOGGLE_LARGE_SMALL
-{      WWT_PANEL,   RESIZE_NONE,    14,     0,   189,    14,   150, 0x0,                     STR_NULL},                           // PFW_WIDGET_SELECT_FACE
-{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,     0,    94,   151,   162, STR_012E_CANCEL,         STR_7047_CANCEL_NEW_FACE_SELECTION}, // PFW_WIDGET_CANCEL
-{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,    95,   189,   151,   162, STR_012F_OK,             STR_7048_ACCEPT_NEW_FACE_SELECTION}, // PFW_WIDGET_ACCEPT
-{    WWT_TEXTBTN,   RESIZE_NONE,    14,    95,   187,    75,    86, STR_7044_MALE,           STR_7049_SELECT_MALE_FACES},         // PFW_WIDGET_MALE
-{    WWT_TEXTBTN,   RESIZE_NONE,    14,    95,   187,    87,    98, STR_7045_FEMALE,         STR_704A_SELECT_FEMALE_FACES},       // PFW_WIDGET_FEMALE
-{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,     2,    93,   137,   148, STR_7046_NEW_FACE,       STR_704B_GENERATE_RANDOM_NEW_FACE},  // PFW_WIDGET_RANDOM_NEW_FACE
-{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,    95,   187,    16,    27, STR_FACE_ADVANCED,       STR_FACE_ADVANCED_TIP},              // PFW_WIDGET_TOGGLE_LARGE_SMALL_BUTTON
+{    WWT_CAPTION,   RESIZE_NONE,    14,    11,   292,     0,    13, STR_7043_FACE_SELECTION, STR_018C_WINDOW_TITLE_DRAG_THIS},    // PFW_WIDGET_CAPTION
+{     WWT_IMGBTN,   RESIZE_NONE,    14,   293,   307,     0,    13, SPR_LARGE_SMALL_WINDOW,  STR_FACE_ADVANCED_TIP},              // PFW_WIDGET_TOGGLE_LARGE_SMALL
+{      WWT_PANEL,   RESIZE_NONE,    14,     0,   307,    14,   311, 0x0,                     STR_NULL},                           // PFW_WIDGET_SELECT_FACE
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,     0,   154,   312,   323, STR_012E_CANCEL,         STR_7047_CANCEL_NEW_FACE_SELECTION}, // PFW_WIDGET_CANCEL
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,    155,  307,   312,   323, STR_012F_OK,             STR_7048_ACCEPT_NEW_FACE_SELECTION}, // PFW_WIDGET_ACCEPT
+{    WWT_TEXTBTN,   RESIZE_NONE,    14,    201,  303,    75,    86, STR_7044_MALE,           STR_7049_SELECT_MALE_FACES},         // PFW_WIDGET_MALE
+{    WWT_TEXTBTN,   RESIZE_NONE,    14,    201,  303,    87,    98, STR_7045_FEMALE,         STR_704A_SELECT_FEMALE_FACES},       // PFW_WIDGET_FEMALE
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,     2,    93,   277,   288, STR_7046_NEW_FACE,       STR_704B_GENERATE_RANDOM_NEW_FACE},  // PFW_WIDGET_RANDOM_NEW_FACE
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,    201,  303,    16,    27, STR_FACE_ADVANCED,       STR_FACE_ADVANCED_TIP},              // PFW_WIDGET_TOGGLE_LARGE_SMALL_BUTTON
 {   WIDGETS_END},
 };
 
 /** Widget description for the advanced player face selection dialog */
 static const Widget _select_player_face_adv_widgets[] = {
 {   WWT_CLOSEBOX,   RESIZE_NONE,    14,     0,    10,     0,    13, STR_00C5,                STR_018B_CLOSE_WINDOW},              // PFW_WIDGET_CLOSEBOX
-{    WWT_CAPTION,   RESIZE_NONE,    14,    11,   204,     0,    13, STR_7043_FACE_SELECTION, STR_018C_WINDOW_TITLE_DRAG_THIS},    // PFW_WIDGET_CAPTION
-{     WWT_IMGBTN,   RESIZE_NONE,    14,   205,   219,     0,    13, SPR_LARGE_SMALL_WINDOW,  STR_FACE_SIMPLE_TIP},                // PFW_WIDGET_TOGGLE_LARGE_SMALL
-{      WWT_PANEL,   RESIZE_NONE,    14,     0,   219,    14,   207, 0x0,                     STR_NULL},                           // PFW_WIDGET_SELECT_FACE
-{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,     0,    94,   208,   219, STR_012E_CANCEL,         STR_7047_CANCEL_NEW_FACE_SELECTION}, // PFW_WIDGET_CANCEL
-{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,    95,   219,   208,   219, STR_012F_OK,             STR_7048_ACCEPT_NEW_FACE_SELECTION}, // PFW_WIDGET_ACCEPT
-{    WWT_TEXTBTN,   RESIZE_NONE,    14,    96,   156,    32,    43, STR_7044_MALE,           STR_7049_SELECT_MALE_FACES},         // PFW_WIDGET_MALE
-{    WWT_TEXTBTN,   RESIZE_NONE,    14,   157,   217,    32,    43, STR_7045_FEMALE,         STR_704A_SELECT_FEMALE_FACES},       // PFW_WIDGET_FEMALE
-{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,     2,    93,   137,   148, STR_RANDOM,              STR_704B_GENERATE_RANDOM_NEW_FACE},  // PFW_WIDGET_RANDOM_NEW_FACE
-{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,    95,   217,    16,    27, STR_FACE_SIMPLE,         STR_FACE_SIMPLE_TIP},                // PFW_WIDGET_TOGGLE_LARGE_SMALL_BUTTON
-{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,     2,    93,   158,   169, STR_FACE_LOAD,           STR_FACE_LOAD_TIP},                  // PFW_WIDGET_LOAD
-{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,     2,    93,   170,   181, STR_FACE_FACECODE,       STR_FACE_FACECODE_TIP},              // PFW_WIDGET_FACECODE
-{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,     2,    93,   182,   193, STR_FACE_SAVE,           STR_FACE_SAVE_TIP},                  // PFW_WIDGET_SAVE
-{    WWT_TEXTBTN,   RESIZE_NONE,    14,    96,   156,    46,    57, STR_FACE_EUROPEAN,       STR_FACE_SELECT_EUROPEAN},           // PFW_WIDGET_ETHNICITY_EUR
-{    WWT_TEXTBTN,   RESIZE_NONE,    14,   157,   217,    46,    57, STR_FACE_AFRICAN,        STR_FACE_SELECT_AFRICAN},            // PFW_WIDGET_ETHNICITY_AFR
-{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   175,   217,    60,    71, STR_EMPTY,               STR_FACE_MOUSTACHE_EARRING_TIP},     // PFW_WIDGET_HAS_MOUSTACHE_EARRING
-{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   175,   217,    72,    83, STR_EMPTY,               STR_FACE_GLASSES_TIP},               // PFW_WIDGET_HAS_GLASSES
-{ WWT_PUSHIMGBTN,   RESIZE_NONE,    14,    175,  183,   110,   121, SPR_ARROW_LEFT,          STR_FACE_EYECOLOUR_TIP},             // PFW_WIDGET_EYECOLOUR_L
-{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,    184,  208,   110,   121, STR_EMPTY,               STR_FACE_EYECOLOUR_TIP},             // PFW_WIDGET_EYECOLOUR
-{ WWT_PUSHIMGBTN,   RESIZE_NONE,    14,    209,  217,   110,   121, SPR_ARROW_RIGHT,         STR_FACE_EYECOLOUR_TIP},             // PFW_WIDGET_EYECOLOUR_R
-{ WWT_PUSHIMGBTN,   RESIZE_NONE,    14,    175,  183,   158,   169, SPR_ARROW_LEFT,          STR_FACE_CHIN_TIP},                  // PFW_WIDGET_CHIN_L
-{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,    184,  208,   158,   169, STR_EMPTY,               STR_FACE_CHIN_TIP},                  // PFW_WIDGET_CHIN
-{ WWT_PUSHIMGBTN,   RESIZE_NONE,    14,    209,  217,   158,   169, SPR_ARROW_RIGHT,         STR_FACE_CHIN_TIP},                  // PFW_WIDGET_CHIN_R
-{ WWT_PUSHIMGBTN,   RESIZE_NONE,    14,    175,  183,    98,   109, SPR_ARROW_LEFT,          STR_FACE_EYEBROWS_TIP},              // PFW_WIDGET_EYEBROWS_L
-{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,    184,  208,    98,   109, STR_EMPTY,               STR_FACE_EYEBROWS_TIP},              // PFW_WIDGET_EYEBROWS
-{ WWT_PUSHIMGBTN,   RESIZE_NONE,    14,    209,  217,    98,   109, SPR_ARROW_RIGHT,         STR_FACE_EYEBROWS_TIP},              // PFW_WIDGET_EYEBROWS_R
-{ WWT_PUSHIMGBTN,   RESIZE_NONE,    14,    175,  183,   146,   157, SPR_ARROW_LEFT,          STR_FACE_LIPS_MOUSTACHE_TIP},        // PFW_WIDGET_LIPS_MOUSTACHE_L
-{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,    184,  208,   146,   157, STR_EMPTY,               STR_FACE_LIPS_MOUSTACHE_TIP},        // PFW_WIDGET_LIPS_MOUSTACHE
-{ WWT_PUSHIMGBTN,   RESIZE_NONE,    14,    209,  217,   146,   157, SPR_ARROW_RIGHT,         STR_FACE_LIPS_MOUSTACHE_TIP},        // PFW_WIDGET_LIPS_MOUSTACHE_R
-{ WWT_PUSHIMGBTN,   RESIZE_NONE,    14,    175,  183,   134,   145, SPR_ARROW_LEFT,          STR_FACE_NOSE_TIP},                  // PFW_WIDGET_NOSE_L
-{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,    184,  208,   134,   145, STR_EMPTY,               STR_FACE_NOSE_TIP},                  // PFW_WIDGET_NOSE
-{ WWT_PUSHIMGBTN,   RESIZE_NONE,    14,    209,  217,   134,   145, SPR_ARROW_RIGHT,         STR_FACE_NOSE_TIP},                  // PFW_WIDGET_NOSE_R
-{ WWT_PUSHIMGBTN,   RESIZE_NONE,    14,    175,  183,    86,    97, SPR_ARROW_LEFT,          STR_FACE_HAIR_TIP},                  // PFW_WIDGET_HAIR_L
-{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,    184,  208,    86,    97, STR_EMPTY,               STR_FACE_HAIR_TIP},                  // PFW_WIDGET_HAIR
-{ WWT_PUSHIMGBTN,   RESIZE_NONE,    14,    209,  217,    86,    97, SPR_ARROW_RIGHT,         STR_FACE_HAIR_TIP},                  // PFW_WIDGET_HAIR_R
-{ WWT_PUSHIMGBTN,   RESIZE_NONE,    14,    175,  183,   170,   181, SPR_ARROW_LEFT,          STR_FACE_JACKET_TIP},                // PFW_WIDGET_JACKET_L
-{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,    184,  208,   170,   181, STR_EMPTY,               STR_FACE_JACKET_TIP},                // PFW_WIDGET_JACKET
-{ WWT_PUSHIMGBTN,   RESIZE_NONE,    14,    209,  217,   170,   181, SPR_ARROW_RIGHT,         STR_FACE_JACKET_TIP},                // PFW_WIDGET_JACKET_R
-{ WWT_PUSHIMGBTN,   RESIZE_NONE,    14,    175,  183,   182,   193, SPR_ARROW_LEFT,          STR_FACE_COLLAR_TIP},                // PFW_WIDGET_COLLAR_L
-{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,    184,  208,   182,   193, STR_EMPTY,               STR_FACE_COLLAR_TIP},                // PFW_WIDGET_COLLAR
-{ WWT_PUSHIMGBTN,   RESIZE_NONE,    14,    209,  217,   182,   193, SPR_ARROW_RIGHT,         STR_FACE_COLLAR_TIP},                // PFW_WIDGET_COLLAR_R
-{ WWT_PUSHIMGBTN,   RESIZE_NONE,    14,    175,  183,   194,   205, SPR_ARROW_LEFT,          STR_FACE_TIE_EARRING_TIP},           // PFW_WIDGET_TIE_EARRING_L
-{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,    184,  208,   194,   205, STR_EMPTY,               STR_FACE_TIE_EARRING_TIP},           // PFW_WIDGET_TIE_EARRING
-{ WWT_PUSHIMGBTN,   RESIZE_NONE,    14,    209,  217,   194,   205, SPR_ARROW_RIGHT,         STR_FACE_TIE_EARRING_TIP},           // PFW_WIDGET_TIE_EARRING_R
-{ WWT_PUSHIMGBTN,   RESIZE_NONE,    14,    175,  183,   122,   133, SPR_ARROW_LEFT,          STR_FACE_GLASSES_TIP_2},             // PFW_WIDGET_GLASSES_L
-{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,    184,  208,   122,   133, STR_EMPTY,               STR_FACE_GLASSES_TIP_2},             // PFW_WIDGET_GLASSES
-{ WWT_PUSHIMGBTN,   RESIZE_NONE,    14,    209,  217,   122,   133, SPR_ARROW_RIGHT,         STR_FACE_GLASSES_TIP_2},             // PFW_WIDGET_GLASSES_R
+{    WWT_CAPTION,   RESIZE_NONE,    14,    11,   313,     0,    13, STR_7043_FACE_SELECTION, STR_018C_WINDOW_TITLE_DRAG_THIS},    // PFW_WIDGET_CAPTION
+{     WWT_IMGBTN,   RESIZE_NONE,    14,   313,   327,     0,    13, SPR_LARGE_SMALL_WINDOW,  STR_FACE_SIMPLE_TIP},                // PFW_WIDGET_TOGGLE_LARGE_SMALL
+{      WWT_PANEL,   RESIZE_NONE,    14,     0,   327,    14,   311, 0x0,                     STR_NULL},                           // PFW_WIDGET_SELECT_FACE
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,     0,   163,   312,   323, STR_012E_CANCEL,         STR_7047_CANCEL_NEW_FACE_SELECTION}, // PFW_WIDGET_CANCEL
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   164,   327,   312,   323, STR_012F_OK,             STR_7048_ACCEPT_NEW_FACE_SELECTION}, // PFW_WIDGET_ACCEPT
+{    WWT_TEXTBTN,   RESIZE_NONE,    14,   202,   262,    32,    43, STR_7044_MALE,           STR_7049_SELECT_MALE_FACES},         // PFW_WIDGET_MALE
+{    WWT_TEXTBTN,   RESIZE_NONE,    14,   263,   323,    32,    43, STR_7045_FEMALE,         STR_704A_SELECT_FEMALE_FACES},       // PFW_WIDGET_FEMALE
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,     2,    93,   257,   268, STR_RANDOM,              STR_704B_GENERATE_RANDOM_NEW_FACE},  // PFW_WIDGET_RANDOM_NEW_FACE
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   201,   323,    16,    27, STR_FACE_SIMPLE,         STR_FACE_SIMPLE_TIP},                // PFW_WIDGET_TOGGLE_LARGE_SMALL_BUTTON
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,     2,    93,   273,   284, STR_FACE_LOAD,           STR_FACE_LOAD_TIP},                  // PFW_WIDGET_LOAD
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,     2,    93,   285,   296, STR_FACE_FACECODE,       STR_FACE_FACECODE_TIP},              // PFW_WIDGET_FACECODE
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,     2,    93,   297,   308, STR_FACE_SAVE,           STR_FACE_SAVE_TIP},                  // PFW_WIDGET_SAVE
+{    WWT_TEXTBTN,   RESIZE_NONE,    14,   202,   262,    46,    57, STR_FACE_EUROPEAN,       STR_FACE_SELECT_EUROPEAN},           // PFW_WIDGET_ETHNICITY_EUR
+{    WWT_TEXTBTN,   RESIZE_NONE,    14,   263,   323,    46,    57, STR_FACE_AFRICAN,        STR_FACE_SELECT_AFRICAN},            // PFW_WIDGET_ETHNICITY_AFR
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   281,   323,    60,    71, STR_EMPTY,               STR_FACE_MOUSTACHE_EARRING_TIP},     // PFW_WIDGET_HAS_MOUSTACHE_EARRING
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,   281,   323,    72,    83, STR_EMPTY,               STR_FACE_GLASSES_TIP},               // PFW_WIDGET_HAS_GLASSES
+{ WWT_PUSHIMGBTN,   RESIZE_NONE,    14,    281,  289,   110,   121, SPR_ARROW_LEFT,          STR_FACE_EYECOLOUR_TIP},             // PFW_WIDGET_EYECOLOUR_L
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,    290,  314,   110,   121, STR_EMPTY,               STR_FACE_EYECOLOUR_TIP},             // PFW_WIDGET_EYECOLOUR
+{ WWT_PUSHIMGBTN,   RESIZE_NONE,    14,    315,  323,   110,   121, SPR_ARROW_RIGHT,         STR_FACE_EYECOLOUR_TIP},             // PFW_WIDGET_EYECOLOUR_R
+{ WWT_PUSHIMGBTN,   RESIZE_NONE,    14,    281,  289,   158,   169, SPR_ARROW_LEFT,          STR_FACE_CHIN_TIP},                  // PFW_WIDGET_CHIN_L
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,    290,  314,   158,   169, STR_EMPTY,               STR_FACE_CHIN_TIP},                  // PFW_WIDGET_CHIN
+{ WWT_PUSHIMGBTN,   RESIZE_NONE,    14,    315,  323,   158,   169, SPR_ARROW_RIGHT,         STR_FACE_CHIN_TIP},                  // PFW_WIDGET_CHIN_R
+{ WWT_PUSHIMGBTN,   RESIZE_NONE,    14,    281,  289,    98,   109, SPR_ARROW_LEFT,          STR_FACE_EYEBROWS_TIP},              // PFW_WIDGET_EYEBROWS_L
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,    290,  314,    98,   109, STR_EMPTY,               STR_FACE_EYEBROWS_TIP},              // PFW_WIDGET_EYEBROWS
+{ WWT_PUSHIMGBTN,   RESIZE_NONE,    14,    315,  323,    98,   109, SPR_ARROW_RIGHT,         STR_FACE_EYEBROWS_TIP},              // PFW_WIDGET_EYEBROWS_R
+{ WWT_PUSHIMGBTN,   RESIZE_NONE,    14,    281,  289,   146,   157, SPR_ARROW_LEFT,          STR_FACE_LIPS_MOUSTACHE_TIP},        // PFW_WIDGET_LIPS_MOUSTACHE_L
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,    290,  314,   146,   157, STR_EMPTY,               STR_FACE_LIPS_MOUSTACHE_TIP},        // PFW_WIDGET_LIPS_MOUSTACHE
+{ WWT_PUSHIMGBTN,   RESIZE_NONE,    14,    315,  323,   146,   157, SPR_ARROW_RIGHT,         STR_FACE_LIPS_MOUSTACHE_TIP},        // PFW_WIDGET_LIPS_MOUSTACHE_R
+{ WWT_PUSHIMGBTN,   RESIZE_NONE,    14,    281,  289,   134,   145, SPR_ARROW_LEFT,          STR_FACE_NOSE_TIP},                  // PFW_WIDGET_NOSE_L
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,    290,  314,   134,   145, STR_EMPTY,               STR_FACE_NOSE_TIP},                  // PFW_WIDGET_NOSE
+{ WWT_PUSHIMGBTN,   RESIZE_NONE,    14,    315,  323,   134,   145, SPR_ARROW_RIGHT,         STR_FACE_NOSE_TIP},                  // PFW_WIDGET_NOSE_R
+{ WWT_PUSHIMGBTN,   RESIZE_NONE,    14,    281,  289,    86,    97, SPR_ARROW_LEFT,          STR_FACE_HAIR_TIP},                  // PFW_WIDGET_HAIR_L
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,    290,  314,    86,    97, STR_EMPTY,               STR_FACE_HAIR_TIP},                  // PFW_WIDGET_HAIR
+{ WWT_PUSHIMGBTN,   RESIZE_NONE,    14,    315,  323,    86,    97, SPR_ARROW_RIGHT,         STR_FACE_HAIR_TIP},                  // PFW_WIDGET_HAIR_R
+{ WWT_PUSHIMGBTN,   RESIZE_NONE,    14,    281,  289,   170,   181, SPR_ARROW_LEFT,          STR_FACE_JACKET_TIP},                // PFW_WIDGET_JACKET_L
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,    290,  314,   170,   181, STR_EMPTY,               STR_FACE_JACKET_TIP},                // PFW_WIDGET_JACKET
+{ WWT_PUSHIMGBTN,   RESIZE_NONE,    14,    315,  323,   170,   181, SPR_ARROW_RIGHT,         STR_FACE_JACKET_TIP},                // PFW_WIDGET_JACKET_R
+{ WWT_PUSHIMGBTN,   RESIZE_NONE,    14,    281,  289,   182,   193, SPR_ARROW_LEFT,          STR_FACE_COLLAR_TIP},                // PFW_WIDGET_COLLAR_L
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,    290,  314,   182,   193, STR_EMPTY,               STR_FACE_COLLAR_TIP},                // PFW_WIDGET_COLLAR
+{ WWT_PUSHIMGBTN,   RESIZE_NONE,    14,    315,  323,   182,   193, SPR_ARROW_RIGHT,         STR_FACE_COLLAR_TIP},                // PFW_WIDGET_COLLAR_R
+{ WWT_PUSHIMGBTN,   RESIZE_NONE,    14,    281,  289,   194,   205, SPR_ARROW_LEFT,          STR_FACE_TIE_EARRING_TIP},           // PFW_WIDGET_TIE_EARRING_L
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,    290,  314,   194,   205, STR_EMPTY,               STR_FACE_TIE_EARRING_TIP},           // PFW_WIDGET_TIE_EARRING
+{ WWT_PUSHIMGBTN,   RESIZE_NONE,    14,    315,  323,   194,   205, SPR_ARROW_RIGHT,         STR_FACE_TIE_EARRING_TIP},           // PFW_WIDGET_TIE_EARRING_R
+{ WWT_PUSHIMGBTN,   RESIZE_NONE,    14,    281,  289,   122,   133, SPR_ARROW_LEFT,          STR_FACE_GLASSES_TIP_2},             // PFW_WIDGET_GLASSES_L
+{ WWT_PUSHTXTBTN,   RESIZE_NONE,    14,    290,  314,   122,   133, STR_EMPTY,               STR_FACE_GLASSES_TIP_2},             // PFW_WIDGET_GLASSES
+{ WWT_PUSHIMGBTN,   RESIZE_NONE,    14,    315,  323,   122,   133, SPR_ARROW_RIGHT,         STR_FACE_GLASSES_TIP_2},             // PFW_WIDGET_GLASSES_R
 {   WIDGETS_END},
 };
 
@@ -830,8 +831,15 @@
 				DrawFaceStringLabel(w, PFW_WIDGET_COLLAR,                STR_FACE_COLLAR,      GetPlayerFaceBits(*pf, PFV_COLLAR,          ge), false);
 			}
 
+      	DrawPixelInfo bk, *old_dpi;
+         old_dpi = _cur_dpi;
+      	_cur_dpi = &bk;
+         *_cur_dpi = *old_dpi;
+         _cur_dpi->zoom = ZOOM_LVL_IN_2X;
+
 			/* Draw the player face picture */
 			DrawPlayerFace(*pf, GetPlayer((PlayerID)w->window_number)->player_color, 2, 16);
+         _cur_dpi = old_dpi;
 			break;
 
 		case WE_CLICK:
@@ -959,7 +967,7 @@
 
 /** normal/simple player face selection window description */
 static const WindowDesc _select_player_face_desc = {
-	WDP_AUTO, WDP_AUTO, 190, 163, 190, 163,
+	WDP_AUTO, WDP_AUTO, 307, 323, 307, 323,
 	WC_PLAYER_FACE, WC_NONE,
 	WDF_STD_TOOLTIPS | WDF_STD_BTN | WDF_DEF_WIDGET | WDF_UNCLICK_BUTTONS,
 	_select_player_face_widgets,
@@ -968,7 +976,7 @@
 
 /** advanced player face selection window description */
 static const WindowDesc _select_player_face_adv_desc = {
-	WDP_AUTO, WDP_AUTO, 220, 220, 220, 220,
+	WDP_AUTO, WDP_AUTO, 327, 324, 327, 324,
 	WC_PLAYER_FACE, WC_NONE,
 	WDF_STD_TOOLTIPS | WDF_STD_BTN | WDF_DEF_WIDGET | WDF_UNCLICK_BUTTONS,
 	_select_player_face_adv_widgets,
Index: src/openttd.cpp
===================================================================
--- src/openttd.cpp	(revision 12652)
+++ src/openttd.cpp	(working copy)
@@ -364,7 +364,9 @@
 		"f"
 #endif
 	;
-
+   DrawPixelInfo dpi;
+   _cur_dpi = &dpi;
+   _cur_dpi->zoom=ZOOM_LVL_NORMAL;
 	MyGetOptData mgo(argc - 1, argv + 1, optformat);
 
 	while ((i = MyGetOpt(&mgo)) != -1) {
@@ -1283,7 +1285,8 @@
 	WP(w, vp_d).dest_scrollpos_y = _saved_scrollpos_y;
 
 	ViewPort *vp = w->viewport;
-	vp->zoom = min(_saved_scrollpos_zoom, ZOOM_LVL_MAX);
+//	vp->zoom = min(_saved_scrollpos_zoom, ZOOM_LVL_MAX);
+   vp->zoom = ZOOM_LVL_NORMAL;
 	vp->virtual_width = ScaleByZoom(vp->width, vp->zoom);
 	vp->virtual_height = ScaleByZoom(vp->height, vp->zoom);
 
